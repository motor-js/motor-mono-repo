{"ast":null,"code":"/**\n * enigma.js v2.7.3\n * Copyright (c) 2021 QlikTech International AB\n * This library is licensed under MIT - See the LICENSE file for full details\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.enigma = factory());\n})(this, function () {\n  'use strict';\n  /**\n   * Utility functions\n   */\n\n  var util = {};\n\n  util.isObject = function isObject(arg) {\n    return typeof arg === 'object' && arg !== null;\n  };\n\n  util.isNumber = function isNumber(arg) {\n    return typeof arg === 'number';\n  };\n\n  util.isUndefined = function isUndefined(arg) {\n    return arg === void 0;\n  };\n\n  util.isFunction = function isFunction(arg) {\n    return typeof arg === 'function';\n  };\n  /**\n   * EventEmitter class\n   */\n\n\n  function EventEmitter() {\n    EventEmitter.init.call(this);\n  }\n\n  var nodeEventEmitter = EventEmitter; // Backwards-compat with node 0.10.x\n\n  EventEmitter.EventEmitter = EventEmitter;\n  EventEmitter.prototype._events = undefined;\n  EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are\n  // added to it. This is a useful default which helps finding memory leaks.\n\n  EventEmitter.defaultMaxListeners = 10;\n\n  EventEmitter.init = function () {\n    this._events = this._events || {};\n    this._maxListeners = this._maxListeners || undefined;\n  }; // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n\n  EventEmitter.prototype.setMaxListeners = function (n) {\n    if (!util.isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');\n    this._maxListeners = n;\n    return this;\n  };\n\n  EventEmitter.prototype.emit = function (type) {\n    var er, handler, len, args, i, listeners;\n    if (!this._events) this._events = {}; // If there is no 'error' event listener then throw.\n\n    if (type === 'error' && !this._events.error) {\n      er = arguments[1];\n\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        throw Error('Uncaught, unspecified \"error\" event.');\n      }\n    }\n\n    handler = this._events[type];\n    if (util.isUndefined(handler)) return false;\n\n    if (util.isFunction(handler)) {\n      switch (arguments.length) {\n        // fast cases\n        case 1:\n          handler.call(this);\n          break;\n\n        case 2:\n          handler.call(this, arguments[1]);\n          break;\n\n        case 3:\n          handler.call(this, arguments[1], arguments[2]);\n          break;\n        // slower\n\n        default:\n          len = arguments.length;\n          args = new Array(len - 1);\n\n          for (i = 1; i < len; i++) args[i - 1] = arguments[i];\n\n          handler.apply(this, args);\n      }\n    } else if (util.isObject(handler)) {\n      len = arguments.length;\n      args = new Array(len - 1);\n\n      for (i = 1; i < len; i++) args[i - 1] = arguments[i];\n\n      listeners = handler.slice();\n      len = listeners.length;\n\n      for (i = 0; i < len; i++) listeners[i].apply(this, args);\n    }\n\n    return true;\n  };\n\n  EventEmitter.prototype.addListener = function (type, listener) {\n    var m;\n    if (!util.isFunction(listener)) throw TypeError('listener must be a function');\n    if (!this._events) this._events = {}; // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n\n    if (this._events.newListener) this.emit('newListener', type, util.isFunction(listener.listener) ? listener.listener : listener);\n    if (!this._events[type]) // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;else if (util.isObject(this._events[type])) // If we've already got an array, just append.\n      this._events[type].push(listener);else // Adding the second element, need to change to array.\n      this._events[type] = [this._events[type], listener]; // Check for listener leak\n\n    if (util.isObject(this._events[type]) && !this._events[type].warned) {\n      var m;\n\n      if (!util.isUndefined(this._maxListeners)) {\n        m = this._maxListeners;\n      } else {\n        m = EventEmitter.defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n\n        if (util.isFunction(console.error)) {\n          console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);\n        }\n\n        if (util.isFunction(console.trace)) console.trace();\n      }\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n  EventEmitter.prototype.once = function (type, listener) {\n    if (!util.isFunction(listener)) throw TypeError('listener must be a function');\n    var fired = false;\n\n    function g() {\n      this.removeListener(type, g);\n\n      if (!fired) {\n        fired = true;\n        listener.apply(this, arguments);\n      }\n    }\n\n    g.listener = listener;\n    this.on(type, g);\n    return this;\n  }; // emits a 'removeListener' event iff the listener was removed\n\n\n  EventEmitter.prototype.removeListener = function (type, listener) {\n    var list, position, length, i;\n    if (!util.isFunction(listener)) throw TypeError('listener must be a function');\n    if (!this._events || !this._events[type]) return this;\n    list = this._events[type];\n    length = list.length;\n    position = -1;\n\n    if (list === listener || util.isFunction(list.listener) && list.listener === listener) {\n      delete this._events[type];\n      if (this._events.removeListener) this.emit('removeListener', type, listener);\n    } else if (util.isObject(list)) {\n      for (i = length; i-- > 0;) {\n        if (list[i] === listener || list[i].listener && list[i].listener === listener) {\n          position = i;\n          break;\n        }\n      }\n\n      if (position < 0) return this;\n\n      if (list.length === 1) {\n        list.length = 0;\n        delete this._events[type];\n      } else {\n        list.splice(position, 1);\n      }\n\n      if (this._events.removeListener) this.emit('removeListener', type, listener);\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.removeAllListeners = function (type) {\n    var key, listeners;\n    if (!this._events) return this; // not listening for removeListener, no need to emit\n\n    if (!this._events.removeListener) {\n      if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];\n      return this;\n    } // emit removeListener for all listeners on all events\n\n\n    if (arguments.length === 0) {\n      for (key in this._events) {\n        if (key === 'removeListener') continue;\n        this.removeAllListeners(key);\n      }\n\n      this.removeAllListeners('removeListener');\n      this._events = {};\n      return this;\n    }\n\n    listeners = this._events[type];\n\n    if (util.isFunction(listeners)) {\n      this.removeListener(type, listeners);\n    } else if (Array.isArray(listeners)) {\n      // LIFO order\n      while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]);\n    }\n\n    delete this._events[type];\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function (type) {\n    var ret;\n    if (!this._events || !this._events[type]) ret = [];else if (util.isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();\n    return ret;\n  };\n\n  EventEmitter.listenerCount = function (emitter, type) {\n    var ret;\n    if (!emitter._events || !emitter._events[type]) ret = 0;else if (util.isFunction(emitter._events[type])) ret = 1;else ret = emitter._events[type].length;\n    return ret;\n  };\n  /**\n  * @module EventEmitter\n  * @private\n  */\n\n\n  var Events = {\n    /**\n    * Function used to add event handling to objects passed in.\n    * @param {Object} obj Object instance that will get event handling.\n    */\n    mixin: function mixin(obj) {\n      Object.keys(nodeEventEmitter.prototype).forEach(function (key) {\n        obj[key] = nodeEventEmitter.prototype[key];\n      });\n      nodeEventEmitter.init(obj);\n    }\n  };\n\n  function _typeof$4(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof$4 = function _typeof(obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof$4 = function _typeof(obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof$4(obj);\n  }\n\n  function _classCallCheck$9(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _inherits$1(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf$1(subClass, superClass);\n  }\n\n  function _createSuper$1(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$1();\n\n    return function _createSuperInternal() {\n      var Super = _getPrototypeOf$1(Derived),\n          result;\n\n      if (hasNativeReflectConstruct) {\n        var NewTarget = _getPrototypeOf$1(this).constructor;\n\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n\n      return _possibleConstructorReturn$1(this, result);\n    };\n  }\n\n  function _possibleConstructorReturn$1(self, call) {\n    if (call && (_typeof$4(call) === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n\n    return _assertThisInitialized$1(self);\n  }\n\n  function _assertThisInitialized$1(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !_isNativeFunction(Class)) return Class;\n\n      if (typeof Class !== \"function\") {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n\n      if (typeof _cache !== \"undefined\") {\n        if (_cache.has(Class)) return _cache.get(Class);\n\n        _cache.set(Class, Wrapper);\n      }\n\n      function Wrapper() {\n        return _construct(Class, arguments, _getPrototypeOf$1(this).constructor);\n      }\n\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      return _setPrototypeOf$1(Wrapper, Class);\n    };\n\n    return _wrapNativeSuper(Class);\n  }\n\n  function _construct(Parent, args, Class) {\n    if (_isNativeReflectConstruct$1()) {\n      _construct = Reflect.construct;\n    } else {\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) _setPrototypeOf$1(instance, Class.prototype);\n        return instance;\n      };\n    }\n\n    return _construct.apply(null, arguments);\n  }\n\n  function _isNativeReflectConstruct$1() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n  }\n\n  function _setPrototypeOf$1(o, p) {\n    _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf$1(o, p);\n  }\n\n  function _getPrototypeOf$1(o) {\n    _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf$1(o);\n  }\n  /**\n   * Error containing a custom error code.\n   * @extends Error\n   * @property {number} code The error code as defined by `errorCodes`.\n   * @property {boolean} enigmaError=true\n   */\n\n\n  var EnigmaError = /*#__PURE__*/function (_Error) {\n    _inherits$1(EnigmaError, _Error);\n\n    var _super = _createSuper$1(EnigmaError);\n\n    function EnigmaError(name, code) {\n      var _this;\n\n      _classCallCheck$9(this, EnigmaError);\n\n      _this = _super.call(this, name);\n      _this.code = code;\n      _this.enigmaError = true;\n      return _this;\n    }\n\n    return EnigmaError;\n  }( /*#__PURE__*/_wrapNativeSuper(Error));\n  /**\n   * Create an enigmaError\n   * @private\n   * @param {Number} code A proper error code from `errorCodes`\n   * @param {String} name A message/name of the enigmaError.\n   * @returns {EnigmaError}\n   */\n\n\n  function createEnigmaError(code, name) {\n    return new EnigmaError(name, code);\n  }\n  /**\n   * This is a list of error codes that can be thrown from enigma.js API calls.\n   * @entry\n   * @see EnigmaError\n   * @enum\n   * @example <caption>Handling an enigma.js error</caption>\n   * const { NOT_CONNECTED } = require('enigma.js/error-codes');\n   * try {\n   *   const layout = await model.getLayout();\n   * } catch (err) {\n   *   if (err.code === NOT_CONNECTED) {\n   *     console.log('Tried to communicate on a session that is closed');\n   *   }\n   * }\n   */\n\n\n  var errorCodes = {\n    /**\n     * You're trying to send data on a socket that's not connected.\n     * @type {number}\n     */\n    NOT_CONNECTED: -1,\n\n    /**\n     * The object you're trying to fetch does not exist.\n     * @type {number}\n     */\n    OBJECT_NOT_FOUND: -2,\n\n    /**\n     * Unexpected RPC response, expected array of patches.\n     * @type {number}\n     */\n    EXPECTED_ARRAY_OF_PATCHES: -3,\n\n    /**\n     * Not an object that can be patched.\n     * @type {number}\n     */\n    PATCH_HAS_NO_PARENT: -4,\n\n    /**\n     * This entry is already defined with another key.\n     * @type {number}\n     */\n    ENTRY_ALREADY_DEFINED: -5,\n\n    /**\n     * You need to supply a configuration.\n     * @type {number}\n     */\n    NO_CONFIG_SUPPLIED: -6,\n\n    /**\n     * There's no promise object available (polyfill required?).\n     * @type {number}\n     */\n    PROMISE_REQUIRED: -7,\n\n    /**\n     * The schema struct type you requested does not exist.\n     * @type {number}\n     */\n    SCHEMA_STRUCT_TYPE_NOT_FOUND: -8,\n\n    /**\n     * Can't override this function.\n     * @type {number}\n     */\n    SCHEMA_MIXIN_CANT_OVERRIDE_FUNCTION: -9,\n\n    /**\n     * Extend is not allowed for this mixin.\n     * @type {number}\n     */\n    SCHEMA_MIXIN_EXTEND_NOT_ALLOWED: -10,\n\n    /**\n     * Session suspended - no interaction allowed.\n     * @type {number}\n     */\n    SESSION_SUSPENDED: -11,\n\n    /**\n     * onlyIfAttached supplied, but you got SESSION_CREATED.\n     * @type {number}\n     */\n    SESSION_NOT_ATTACHED: -12\n  };\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n\n      if (enumerableOnly) {\n        symbols = symbols.filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n      }\n\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _classCallCheck$8(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties$8(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass$8(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties$8(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties$8(Constructor, staticProps);\n    return Constructor;\n  }\n\n  var RPC_CLOSE_NORMAL = 1000;\n  var RPC_CLOSE_MANUAL_SUSPEND$1 = 4000;\n  var cacheId = 0;\n  /**\n   * The QIX Engine session object.\n   */\n\n  var Session = /*#__PURE__*/function () {\n    /**\n     * Handles all JSON-RPC notification events, 'notification:* or handles a specific JSON-RPC\n     * notification event, 'notification:OnConnected'. These events depend on the product from which\n     * you use QIX Engine.\n     * @event Session#notification\n     * @type {Object}\n     * @example <caption>Bind the notification events</caption>\n     * // bind all notifications to console.log:\n     * session.on('notification:*', console.log);\n     * // bind a specific notification to console.log:\n     * session.on('notification:OnConnected', console.log);\n     */\n\n    /**\n     * Handles websocket messages. Generally used for debugging purposes. `traffic:*` will handle all\n     * websocket messages, `traffic:sent` will handle outgoing messages, and `traffic:received` will\n     * handle incoming messages.\n     * @event Session#traffic\n     * @type {Object}\n     * @example <caption>Bind the traffic events</caption>\n     * // bind both in- and outbound traffic to console.log:\n     * session.on('traffic:*', console.log);\n     * // bind outbound traffic to console.log:\n     * session.on('traffic:sent', console.log);\n     * // bind inbound traffic to console.log:\n     * session.on('traffic:received', console.log);\n     */\n    function Session(options) {\n      _classCallCheck$8(this, Session);\n\n      var session = this;\n      Object.assign(session, options);\n      this.Promise = this.config.Promise;\n      this.definition = this.config.definition;\n      Events.mixin(session);\n      cacheId += 1;\n      session.id = cacheId;\n      session.rpc.on('socket-error', session.onRpcError.bind(session));\n      session.rpc.on('closed', session.onRpcClosed.bind(session));\n      session.rpc.on('message', session.onRpcMessage.bind(session));\n      session.rpc.on('notification', session.onRpcNotification.bind(session));\n      session.rpc.on('traffic', session.onRpcTraffic.bind(session));\n      session.on('closed', function () {\n        return session.onSessionClosed();\n      });\n    }\n    /**\n    * Event handler for re-triggering error events from RPC.\n    * @private\n    * @emits socket-error\n    * @param {Error} err Webocket error event.\n    */\n\n\n    _createClass$8(Session, [{\n      key: \"onRpcError\",\n      value: function onRpcError(err) {\n        if (this.suspendResume.isSuspended) {\n          return;\n        }\n\n        this.emit('socket-error', err);\n      }\n      /**\n      * Event handler for the RPC close event.\n      * @private\n      * @emits Session#suspended\n      * @emits Session#closed\n      * @param {Event} evt WebSocket close event.\n      */\n\n    }, {\n      key: \"onRpcClosed\",\n      value: function onRpcClosed(evt) {\n        var _this = this;\n        /**\n         * Handles suspended state. This event is triggered in two cases (listed below). It is useful\n         * in scenarios where, for example, you want to block interaction with your application until\n         * you resume again. Or, if config.suspendOnClose is true and there was a network disconnect\n         * (socket closed) or if you ran session.suspend().\n         * @event Session#suspended\n         * @type {Object}\n         * @param {Object} evt Event object.\n         * @param {String} evt.initiator String indication what triggered the suspended state. Possible\n         * values network, manual.\n         * @example <caption>Handling session suspended</caption>\n         * session.on('suspended', () => {\n         *   console.log('Session was suspended, retrying...');\n         *   session.resume();\n         * });\n         */\n\n\n        if (this.suspendResume.isSuspended) {\n          return;\n        }\n\n        if (evt.code === RPC_CLOSE_NORMAL || evt.code === RPC_CLOSE_MANUAL_SUSPEND$1) {\n          return;\n        }\n\n        if (this.config.suspendOnClose) {\n          var code = evt.code,\n              reason = evt.reason;\n          this.suspendResume.suspend().then(function () {\n            return _this.emit('suspended', {\n              initiator: 'network',\n              code: code,\n              reason: reason\n            });\n          });\n        } else {\n          this.emit('closed', evt);\n        }\n      }\n      /**\n      * Event handler for the RPC message event.\n      * @private\n      * @param {Object} response JSONRPC response.\n      */\n\n    }, {\n      key: \"onRpcMessage\",\n      value: function onRpcMessage(response) {\n        var _this2 = this;\n\n        if (this.suspendResume.isSuspended) {\n          return;\n        }\n\n        if (response.change) {\n          response.change.forEach(function (handle) {\n            return _this2.emitHandleChanged(handle);\n          });\n        }\n\n        if (response.close) {\n          response.close.forEach(function (handle) {\n            return _this2.emitHandleClosed(handle);\n          });\n        }\n      }\n      /**\n      * Event handler for the RPC notification event.\n      * @private\n      * @emits Session#notification\n      * @param {Object} response The JSONRPC notification.\n      */\n\n    }, {\n      key: \"onRpcNotification\",\n      value: function onRpcNotification(response) {\n        this.emit('notification:*', response.method, response.params);\n        this.emit(\"notification:\".concat(response.method), response.params);\n      }\n      /**\n      * Event handler for the RPC traffic event.\n      * @private\n      * @emits Session#traffic\n      * @param {String} dir The traffic direction, sent or received.\n      * @param {Object} data JSONRPC request/response/WebSocket message.\n      * @param {Number} handle The associated handle.\n      */\n\n    }, {\n      key: \"onRpcTraffic\",\n      value: function onRpcTraffic(dir, data, handle) {\n        this.emit('traffic:*', dir, data);\n        this.emit(\"traffic:\".concat(dir), data);\n        var api = this.apis.getApi(handle);\n\n        if (api) {\n          api.emit('traffic:*', dir, data);\n          api.emit(\"traffic:\".concat(dir), data);\n        }\n      }\n      /**\n      * Event handler for cleaning up API instances when a session has been closed.\n      * @private\n      * @emits API#closed\n      */\n\n    }, {\n      key: \"onSessionClosed\",\n      value: function onSessionClosed() {\n        this.apis.getApis().forEach(function (entry) {\n          entry.api.emit('closed');\n          entry.api.removeAllListeners();\n        });\n        this.apis.clear();\n      }\n      /**\n       * Function used to get an API for a backend object.\n       * @private\n       * @param {Object} args Arguments used to create object API.\n       * @param {Number} args.handle Handle of the backend object.\n       * @param {String} args.id ID of the backend object.\n       * @param {String} args.type QIX type of the backend object. Can for example\n       *                           be \"Doc\" or \"GenericVariable\".\n       * @param {String} args.genericType Custom type of the backend object, if defined in qInfo.\n       * @returns {Object} Returns the generated and possibly augmented API.\n       */\n\n    }, {\n      key: \"getObjectApi\",\n      value: function getObjectApi(args) {\n        var handle = args.handle,\n            id = args.id,\n            type = args.type,\n            genericType = args.genericType;\n        var api = this.apis.getApi(handle);\n\n        if (api) {\n          return api;\n        }\n\n        var factory = this.definition.generate(type);\n        api = factory(this, handle, id, genericType);\n        this.apis.add(handle, api);\n        return api;\n      }\n      /**\n      * Establishes the websocket against the configured URL and returns the Global instance.\n      * @emits Session#opened\n      * @returns {Promise<Object>} Eventually resolved if the connection was successful.\n      * @example <caption>Opening a sesssion</caption>\n      * session.open().then(() => {\n      *   console.log('Session was opened');\n      * });\n      */\n\n    }, {\n      key: \"open\",\n      value: function open() {\n        var _this3 = this;\n        /**\n         * Handles opened state. This event is triggered whenever the websocket is connected and\n         * ready for communication.\n         * @event Session#opened\n         * @type {Object}\n         * @example <caption>Bind the session opened event</caption>\n         * session.on('opened', () => {\n         *   console.log('Session was opened');\n         * });\n         */\n\n\n        if (!this.globalPromise) {\n          var args = {\n            handle: -1,\n            id: 'Global',\n            type: 'Global',\n            genericType: 'Global'\n          };\n          this.globalPromise = this.rpc.open().then(function () {\n            return _this3.getObjectApi(args);\n          }).then(function (global) {\n            _this3.emit('opened');\n\n            return global;\n          });\n        }\n\n        return this.globalPromise;\n      }\n      /**\n      * Function used to send data on the RPC socket.\n      * @param {Object} request The request to be sent. (data and some meta info)\n      * @returns {Object} Returns a promise instance.\n      */\n\n    }, {\n      key: \"send\",\n      value: function send(request) {\n        var _this4 = this;\n\n        if (this.suspendResume.isSuspended) {\n          return this.Promise.reject(createEnigmaError(errorCodes.SESSION_SUSPENDED, 'Session suspended'));\n        }\n\n        request.id = this.rpc.createRequestId();\n        var promise = this.intercept.executeRequests(this, this.Promise.resolve(request)).then(function (augmentedRequest) {\n          var data = _objectSpread(_objectSpread({}, _this4.config.protocol), augmentedRequest); // the outKey value is used by multiple-out interceptor, at some point\n          // we need to refactor that implementation and figure out how to transport\n          // this value without hijacking the JSONRPC request object:\n\n\n          delete data.outKey;\n\n          var response = _this4.rpc.send(data);\n\n          augmentedRequest.retry = function () {\n            return _this4.send(request);\n          };\n\n          return _this4.intercept.executeResponses(_this4, response, augmentedRequest);\n        });\n        Session.addToPromiseChain(promise, 'requestId', request.id);\n        return promise;\n      }\n      /**\n      * Suspends the enigma.js session by closing the websocket and rejecting all method calls\n      * until it is has resumed again.\n      * @emits Session#suspended\n      * @param {Number} [code=4000] - The reason code for suspending the connection.\n      * @param {String} [reason=\"\"] - The human readable string describing\n      * why the connection is suspended.\n      * @returns {Promise<Object>} Eventually resolved when the websocket has been closed.\n      * @example <caption>Suspending a session</caption>\n      * session.suspend().then(() => {\n      *   console.log('Session was suspended');\n      * });\n      */\n\n    }, {\n      key: \"suspend\",\n      value: function suspend() {\n        var _this5 = this;\n\n        var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4000;\n        var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n        return this.suspendResume.suspend(code, reason).then(function () {\n          return _this5.emit('suspended', {\n            initiator: 'manual',\n            code: code,\n            reason: reason\n          });\n        });\n      }\n      /**\n      * Resumes a previously suspended enigma.js session by recreating the websocket and,\n      * if possible, reopen the document as well as refreshing the internal cashes. If successful,\n      * changed events will be triggered on all generated APIs, and on the ones it was unable to\n      * restore, the closed event will be triggered.\n      * @emits Session#resumed\n      * @param {Boolean} onlyIfAttached If true, resume only if the session was reattached properly.\n      * @returns {Promise<Object>} Eventually resolved when the websocket (and potentially the\n      * previously opened document, and generated APIs) has been restored; it is rejected when it fails\n      * any of those steps, or when onlyIfAttached is true and a new session was created.\n      * @example <caption>Resuming a session</caption>\n      * session.resume(true).then(() => {\n      *   console.log('Session was resumed by re-attaching');\n      * });\n      */\n\n    }, {\n      key: \"resume\",\n      value: function resume(onlyIfAttached) {\n        var _this6 = this;\n        /**\n         * Handles resumed state. This event is triggered when the session was properly resumed. It is\n         * useful in scenarios where, for example, you can close blocking modal dialogs and allow the\n         * user to interact with your application again.\n         * @event Session#resumed\n         * @type {Object}\n         * @example <caption>Handling session resumed</caption>\n         * session.on('resumed', () => {\n         *   console.log('Session was resumed, we can close that \"reconnecting\" dialog now');\n         * });\n         */\n\n\n        return this.suspendResume.resume(onlyIfAttached).then(function (value) {\n          _this6.emit('resumed');\n\n          return value;\n        });\n      }\n      /**\n      * Closes the websocket and cleans up internal caches. Also triggers the closed event\n      * on all generated APIs. Note that you have to manually invoke this when you want to\n      * close a session and config.suspendOnClose is true.\n      * @emits Session#closed\n      * @param {Number} [code=1000] - The reason code for closing the connection.\n      * @param {String} [reason=\"\"] - The human readable string describing why the connection is closed.\n      * @returns {Promise<Object>} Eventually resolved when the websocket has been closed.\n      * @example <caption>Closing a session</caption>\n      * session.close().then(() => {\n      *   console.log('Session was closed');\n      * });\n      */\n\n    }, {\n      key: \"close\",\n      value: function close() {\n        var _this7 = this;\n\n        var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;\n        var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n        /**\n         * Handles closed state. This event is triggered when the underlying websocket is closed and\n         * config.suspendOnClose is false.\n         * @event Session#closed\n         * @type {Object}\n         * @example <caption>Handling session closed</caption>\n         * session.on('closed', () => {\n         *   console.log('Session was closed, clean up!');\n         * });\n         */\n\n        this.globalPromise = undefined;\n        return this.rpc.close(code, reason).then(function (evt) {\n          return _this7.emit('closed', evt);\n        });\n      }\n      /**\n      * Given a handle, this function will emit the 'changed' event on the\n      * corresponding API instance.\n      * @private\n      * @param {Number} handle The handle of the API instance.\n      * @emits API#changed\n      */\n\n    }, {\n      key: \"emitHandleChanged\",\n      value: function emitHandleChanged(handle) {\n        var api = this.apis.getApi(handle);\n\n        if (api) {\n          api.emit('changed');\n        }\n      }\n      /**\n      * Given a handle, this function will emit the 'closed' event on the\n      * corresponding API instance.\n      * @private\n      * @param {Number} handle The handle of the API instance.\n      * @emits API#closed\n      */\n\n    }, {\n      key: \"emitHandleClosed\",\n      value: function emitHandleClosed(handle) {\n        var api = this.apis.getApi(handle);\n\n        if (api) {\n          api.emit('closed');\n          api.removeAllListeners();\n        }\n      }\n      /**\n      * Function used to add info on the promise chain.\n      * @private\n      * @param {Promise<Object>} promise The promise to add info on.\n      * @param {String} name The property to add info on.\n      * @param {Any} value The info to add.\n      */\n\n    }], [{\n      key: \"addToPromiseChain\",\n      value: function addToPromiseChain(promise, name, value) {\n        promise[name] = value;\n        var then = promise.then;\n\n        promise.then = function patchedThen() {\n          for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n            params[_key] = arguments[_key];\n          }\n\n          var chain = then.apply(this, params);\n          Session.addToPromiseChain(chain, name, value);\n          return chain;\n        };\n      }\n    }]);\n\n    return Session;\n  }();\n\n  function _classCallCheck$7(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties$7(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass$7(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties$7(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties$7(Constructor, staticProps);\n    return Constructor;\n  }\n  /**\n  * Key-value cache\n  * @private\n  */\n\n\n  var KeyValueCache = /*#__PURE__*/function () {\n    function KeyValueCache() {\n      _classCallCheck$7(this, KeyValueCache);\n\n      this.entries = {};\n    }\n    /**\n    * Adds an entry.\n    * @private\n    * @function KeyValueCache#add\n    * @param {String} key The key representing an entry.\n    * @param {*} entry The entry to be added.\n    */\n\n\n    _createClass$7(KeyValueCache, [{\n      key: \"add\",\n      value: function add(key, entry) {\n        key += '';\n\n        if (typeof this.entries[key] !== 'undefined') {\n          throw createEnigmaError(errorCodes.ENTRY_ALREADY_DEFINED, \"Entry already defined with key \".concat(key));\n        }\n\n        this.entries[key] = entry;\n      }\n      /**\n      * Sets an entry.\n      * @private\n      * @function KeyValueCache#set\n      * @param {String} key The key representing an entry.\n      * @param {*} entry The entry.\n      */\n\n    }, {\n      key: \"set\",\n      value: function set(key, entry) {\n        key += '';\n        this.entries[key] = entry;\n      }\n      /**\n      * Removes an entry.\n      * @private\n      * @function KeyValueCache#remove\n      * @param {String} key The key representing an entry.\n      */\n\n    }, {\n      key: \"remove\",\n      value: function remove(key) {\n        delete this.entries[key];\n      }\n      /**\n      * Gets an entry.\n      * @private\n      * @function KeyValueCache#get\n      * @param {String} key The key representing an entry.\n      * @returns {*} The entry for the key.\n      */\n\n    }, {\n      key: \"get\",\n      value: function get(key) {\n        return this.entries[key];\n      }\n      /**\n      * Gets a list of all entries.\n      * @private\n      * @function KeyValueCache#getAll\n      * @returns {Array} The list of entries including its `key` and `value` properties.\n      */\n\n    }, {\n      key: \"getAll\",\n      value: function getAll() {\n        var _this = this;\n\n        return Object.keys(this.entries).map(function (key) {\n          return {\n            key: key,\n            value: _this.entries[key]\n          };\n        });\n      }\n      /**\n      * Gets a key for an entry.\n      * @private\n      * @function KeyValueCache#getKey\n      * @param {*} entry The entry to locate the key for.\n      * @returns {String} The key representing an entry.\n      */\n\n    }, {\n      key: \"getKey\",\n      value: function getKey(entry) {\n        var _this2 = this;\n\n        return Object.keys(this.entries).filter(function (key) {\n          return _this2.entries[key] === entry;\n        })[0];\n      }\n      /**\n      * Clears the cache of all entries.\n      * @private\n      * @function KeyValueCache#clear\n      */\n\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        this.entries = {};\n      }\n    }]);\n\n    return KeyValueCache;\n  }();\n\n  function _classCallCheck$6(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties$6(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass$6(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties$6(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties$6(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _typeof$3(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof$3 = function _typeof(obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof$3 = function _typeof(obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof$3(obj);\n  }\n\n  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n  /**\n  * Returns the camelCase counterpart of a symbol.\n  * @private\n  * @param {String} symbol The symbol.\n  * @return the camelCase counterpart.\n  */\n\n  function toCamelCase(symbol) {\n    return symbol.substring(0, 1).toLowerCase() + symbol.substring(1);\n  }\n  /**\n   * A facade function that allows parameters to be passed either by name\n   * (through an object), or by position (through an array).\n   * @private\n   * @param {Function} base The function that is being overriden. Will be\n   *                        called with parameters in array-form.\n   * @param {Object} defaults Parameter list and it's default values.\n   * @param {*} params The parameters.\n   */\n\n\n  function namedParamFacade(base, defaults) {\n    for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      params[_key - 2] = arguments[_key];\n    }\n\n    if (params.length === 1 && _typeof$3(params[0]) === 'object' && !Array.isArray(params[0])) {\n      var valid = Object.keys(params[0]).every(function (key) {\n        return hasOwnProperty$1.call(defaults, key);\n      });\n\n      if (valid) {\n        params = Object.keys(defaults).map(function (key) {\n          return params[0][key] || defaults[key];\n        });\n      }\n    }\n\n    return base.apply(this, params);\n  }\n  /**\n  * Qix schema definition.\n  * @private\n  */\n\n\n  var Schema = /*#__PURE__*/function () {\n    /**\n    * Create a new schema instance.\n    * @private\n    * @param {Configuration} config The configuration for QIX.\n    */\n    function Schema(config) {\n      _classCallCheck$6(this, Schema);\n\n      this.config = config;\n      this.Promise = config.Promise;\n      this.schema = config.schema;\n      this.mixins = new KeyValueCache();\n      this.types = new KeyValueCache();\n    }\n\n    _createClass$6(Schema, [{\n      key: \"registerMixin\",\n      value: function registerMixin(_ref) {\n        var _this = this;\n\n        var types = _ref.types,\n            type = _ref.type,\n            extend = _ref.extend,\n            override = _ref.override,\n            init = _ref.init;\n\n        if (!Array.isArray(types)) {\n          types = [types];\n        } // to support a single type\n\n\n        if (type) {\n          types.push(type);\n        }\n\n        var cached = {\n          extend: extend,\n          override: override,\n          init: init\n        };\n        types.forEach(function (typeKey) {\n          var entryList = _this.mixins.get(typeKey);\n\n          if (entryList) {\n            entryList.push(cached);\n          } else {\n            _this.mixins.add(typeKey, [cached]);\n          }\n        });\n      }\n      /**\n      * Function used to generate a type definition.\n      * @private\n      * @param {String} type The type.\n      * @returns {{create: Function, def: Object}} Returns an object with a definition\n      *          of the type and a create factory.\n      */\n\n    }, {\n      key: \"generate\",\n      value: function generate(type) {\n        var entry = this.types.get(type);\n\n        if (entry) {\n          return entry;\n        }\n\n        if (!this.schema.structs[type]) {\n          throw createEnigmaError(errorCodes.SCHEMA_STRUCT_TYPE_NOT_FOUND, \"\".concat(type, \" not found\"));\n        }\n\n        var factory = this.generateApi(type, this.schema.structs[type]);\n        this.types.add(type, factory);\n        return factory;\n      }\n      /**\n      * Function used to generate an API definition for a given type.\n      * @private\n      * @param {String} type The type to generate.\n      * @param {Object} schema The schema describing the type.\n      * @returns {{create: (function(session:Object, handle:Number, id:String,\n      *          customKey:String)), def: Object}} Returns the API definition.\n      */\n\n    }, {\n      key: \"generateApi\",\n      value: function generateApi(type, schema) {\n        var api = Object.create({});\n        this.generateDefaultApi(api, schema); // Generate default\n\n        this.mixinType(type, api); // Mixin default type\n\n        this.mixinNamedParamFacade(api, schema); // Mixin named parameter support\n\n        return function create(session, handle, id, customKey) {\n          var _this2 = this;\n\n          var instance = Object.create(api);\n          Events.mixin(instance); // Always mixin event-emitter per instance\n\n          Object.defineProperties(instance, {\n            session: {\n              enumerable: true,\n              value: session\n            },\n            handle: {\n              enumerable: true,\n              value: handle,\n              writable: true\n            },\n            id: {\n              enumerable: true,\n              value: id\n            },\n            type: {\n              enumerable: true,\n              value: type\n            },\n            genericType: {\n              enumerable: true,\n              value: customKey\n            }\n          });\n          var mixinList = this.mixins.get(type) || [];\n\n          if (customKey !== type) {\n            this.mixinType(customKey, instance); // Mixin custom types\n\n            mixinList = mixinList.concat(this.mixins.get(customKey) || []);\n          }\n\n          mixinList.forEach(function (mixin) {\n            if (typeof mixin.init === 'function') {\n              mixin.init({\n                config: _this2.config,\n                api: instance\n              });\n            }\n          });\n          return instance;\n        }.bind(this);\n      }\n      /**\n      * Function used to generate the methods with the right handlers to the object\n      * API that is being generated.\n      * @private\n      * @param {Object} api The object API that is currently being generated.\n      * @param {Object} schema The API definition.\n      */\n\n    }, {\n      key: \"generateDefaultApi\",\n      value: function generateDefaultApi(api, schema) {\n        Object.keys(schema).forEach(function (method) {\n          var out = schema[method].Out;\n          var outKey = out.length === 1 ? out[0].Name : -1;\n          var fnName = toCamelCase(method);\n\n          api[fnName] = function generatedMethod() {\n            for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              params[_key2] = arguments[_key2];\n            }\n\n            return this.session.send({\n              handle: this.handle,\n              method: method,\n              params: params,\n              outKey: outKey\n            });\n          };\n        });\n      }\n      /**\n      * Function used to add mixin methods to a specified API.\n      * @private\n      * @param {String} type Used to specify which mixin should be woven in.\n      * @param {Object} api The object that will be woven.\n      */\n\n    }, {\n      key: \"mixinType\",\n      value: function mixinType(type, api) {\n        var mixinList = this.mixins.get(type);\n\n        if (mixinList) {\n          mixinList.forEach(function (_ref2) {\n            var _ref2$extend = _ref2.extend,\n                extend = _ref2$extend === void 0 ? {} : _ref2$extend,\n                _ref2$override = _ref2.override,\n                override = _ref2$override === void 0 ? {} : _ref2$override;\n            Object.keys(override).forEach(function (key) {\n              if (typeof api[key] === 'function' && typeof override[key] === 'function') {\n                var baseFn = api[key];\n\n                api[key] = function wrappedFn() {\n                  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n                    args[_key3] = arguments[_key3];\n                  }\n\n                  return override[key].apply(this, [baseFn.bind(this)].concat(args));\n                };\n              } else {\n                throw createEnigmaError(errorCodes.SCHEMA_MIXIN_CANT_OVERRIDE_FUNCTION, \"No function to override. Type: \".concat(type, \" function: \").concat(key));\n              }\n            });\n            Object.keys(extend).forEach(function (key) {\n              // handle overrides\n              if (typeof api[key] === 'function' && typeof extend[key] === 'function') {\n                throw createEnigmaError(errorCodes.SCHEMA_MIXIN_EXTEND_NOT_ALLOWED, \"Extend is not allowed for this mixin. Type: \".concat(type, \" function: \").concat(key));\n              } else {\n                api[key] = extend[key];\n              }\n            });\n          });\n        }\n      }\n      /**\n      * Function used to mixin the named parameter facade.\n      * @private\n      * @param {Object} api The object API that is currently being generated.\n      * @param {Object} schema The API definition.\n      */\n\n    }, {\n      key: \"mixinNamedParamFacade\",\n      value: function mixinNamedParamFacade(api, schema) {\n        Object.keys(schema).forEach(function (key) {\n          var fnName = toCamelCase(key);\n          var base = api[fnName];\n          var defaults = schema[key].In.reduce(function (result, item) {\n            result[item.Name] = item.DefaultValue;\n            return result;\n          }, {});\n\n          api[fnName] = function namedParamWrapper() {\n            for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n              params[_key4] = arguments[_key4];\n            }\n\n            return namedParamFacade.apply(this, [base, defaults].concat(params));\n          };\n        });\n      }\n    }]);\n\n    return Schema;\n  }();\n\n  function _classCallCheck$5(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties$5(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass$5(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties$5(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties$5(Constructor, staticProps);\n    return Constructor;\n  }\n  /**\n   * Helper class for handling RPC calls\n   * @private\n   */\n\n\n  var RPCResolver = /*#__PURE__*/function () {\n    function RPCResolver(id, handle, resolve, reject) {\n      _classCallCheck$5(this, RPCResolver);\n\n      Events.mixin(this);\n      this.id = id;\n      this.handle = handle;\n      this.resolve = resolve;\n      this.reject = reject;\n    }\n\n    _createClass$5(RPCResolver, [{\n      key: \"resolveWith\",\n      value: function resolveWith(data) {\n        this.resolve(data);\n        this.emit('resolved', this.id);\n      }\n    }, {\n      key: \"rejectWith\",\n      value: function rejectWith(err) {\n        this.reject(err);\n        this.emit('rejected', this.id);\n      }\n    }]);\n\n    return RPCResolver;\n  }();\n\n  function _classCallCheck$4(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties$4(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass$4(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties$4(Constructor, staticProps);\n    return Constructor;\n  }\n  /**\n  * This class handles remote procedure calls on a web socket.\n  * @private\n  */\n\n\n  var RPC = /*#__PURE__*/function () {\n    /**\n    * Create a new RPC instance.\n    * @private\n    * @param {Object} options The configuration options for this class.\n    * @param {Function} options.Promise The promise constructor to use.\n    * @param {String} options.url The complete websocket URL used to connect.\n    * @param {Function} options.createSocket The function callback to create a WebSocket.\n    */\n    function RPC(options) {\n      _classCallCheck$4(this, RPC);\n\n      Object.assign(this, options);\n      Events.mixin(this);\n      this.resolvers = {};\n      this.requestId = 0;\n      this.openedPromise = undefined;\n    }\n    /**\n    * Opens a connection to the configured endpoint.\n    * @private\n    * @param {Boolean} force - ignores all previous and outstanding open calls if set to true.\n    * @returns {Object} A promise instance.\n    */\n\n\n    _createClass$4(RPC, [{\n      key: \"open\",\n      value: function open() {\n        var _this = this;\n\n        var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n        if (!force && this.openedPromise) {\n          return this.openedPromise;\n        }\n\n        try {\n          this.socket = this.createSocket(this.url);\n        } catch (err) {\n          return this.Promise.reject(err);\n        }\n\n        this.socket.onopen = this.onOpen.bind(this);\n        this.socket.onclose = this.onClose.bind(this);\n        this.socket.onerror = this.onError.bind(this);\n        this.socket.onmessage = this.onMessage.bind(this);\n        this.openedPromise = new this.Promise(function (resolve, reject) {\n          return _this.registerResolver('opened', null, resolve, reject);\n        });\n        this.closedPromise = new this.Promise(function (resolve, reject) {\n          return _this.registerResolver('closed', null, resolve, reject);\n        });\n        return this.openedPromise;\n      }\n      /**\n      * Resolves the open promise when a connection is successfully established.\n      * @private\n      */\n\n    }, {\n      key: \"onOpen\",\n      value: function onOpen() {\n        var _this2 = this;\n\n        this.resolvers.opened.resolveWith(function () {\n          return _this2.closedPromise;\n        });\n      }\n      /**\n      * Resolves the close promise when a connection is closed.\n      * @private\n      * @param {Object} event - The event describing close.\n      */\n\n    }, {\n      key: \"onClose\",\n      value: function onClose(event) {\n        this.emit('closed', event);\n\n        if (this.resolvers && this.resolvers.closed) {\n          this.resolvers.closed.resolveWith(event);\n        }\n\n        this.rejectAllOutstandingResolvers(createEnigmaError(errorCodes.NOT_CONNECTED, 'Socket closed'));\n      }\n      /**\n      * Closes a connection.\n      * @private\n      * @param {Number} [code=1000] - The reason code for closing the connection.\n      * @param {String} [reason=\"\"] - The human readable string describing why the connection is closed.\n      * @returns {Object} Returns a promise instance.\n      */\n\n    }, {\n      key: \"close\",\n      value: function close() {\n        var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;\n        var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n        if (this.socket) {\n          this.socket.close(code, reason);\n          this.socket = null;\n        }\n\n        return this.closedPromise;\n      }\n      /**\n      * Emits an error event and rejects the open promise if an error is raised on the connection.\n      * @private\n      * @param {Object} event - The event describing the error.\n      */\n\n    }, {\n      key: \"onError\",\n      value: function onError(event) {\n        if (this.resolvers.opened) {\n          this.resolvers.opened.rejectWith(event);\n        } else {\n          // only emit errors after the initial open promise has been resolved,\n          // this makes it possible to catch early websocket errors as well\n          // as run-time ones:\n          this.emit('socket-error', event);\n        }\n\n        this.rejectAllOutstandingResolvers(createEnigmaError(errorCodes.NOT_CONNECTED, 'Socket error'));\n      }\n      /**\n      * Parses the onMessage event on the connection and resolve the promise for the request.\n      * @private\n      * @param {Object} event - The event describing the message.\n      */\n\n    }, {\n      key: \"onMessage\",\n      value: function onMessage(event) {\n        var data = JSON.parse(event.data);\n        var resolver = this.resolvers[data.id] || {};\n        this.emit('traffic', 'received', data, resolver.handle);\n\n        if (typeof data.id !== 'undefined') {\n          this.emit('message', data);\n          this.resolvers[data.id].resolveWith(data);\n        } else {\n          this.emit(data.params ? 'notification' : 'message', data);\n        }\n      }\n      /**\n      * Rejects all outstanding resolvers.\n      * @private\n      * @param {Object} reason - The reject reason.\n      */\n\n    }, {\n      key: \"rejectAllOutstandingResolvers\",\n      value: function rejectAllOutstandingResolvers(reason) {\n        var _this3 = this;\n\n        Object.keys(this.resolvers).forEach(function (id) {\n          if (id === 'opened' || id === 'closed') {\n            return; // \"opened\" and \"closed\" should not be handled here\n          }\n\n          var resolver = _this3.resolvers[id];\n          resolver.rejectWith(reason);\n        });\n      }\n      /**\n      * Unregisters a resolver.\n      * @private\n      * @param {Number|String} id - The ID to unregister the resolver with.\n      */\n\n    }, {\n      key: \"unregisterResolver\",\n      value: function unregisterResolver(id) {\n        var resolver = this.resolvers[id];\n        resolver.removeAllListeners();\n        delete this.resolvers[id];\n      }\n      /**\n      * Registers a resolver.\n      * @private\n      * @param {Number|String} id - The ID to register the resolver with.\n      * @param {Number} handle - The associated handle.\n      * @returns {Function} The promise executor function.\n      */\n\n    }, {\n      key: \"registerResolver\",\n      value: function registerResolver(id, handle, resolve, reject) {\n        var _this4 = this;\n\n        var resolver = new RPCResolver(id, handle, resolve, reject);\n        this.resolvers[id] = resolver;\n        resolver.on('resolved', function (resolvedId) {\n          return _this4.unregisterResolver(resolvedId);\n        });\n        resolver.on('rejected', function (rejectedId) {\n          return _this4.unregisterResolver(rejectedId);\n        });\n      }\n      /**\n      * Sends data on the socket.\n      * @private\n      * @param {Object} data - The data to send.\n      * @returns {Object} A promise instance.\n      */\n\n    }, {\n      key: \"send\",\n      value: function send(data) {\n        var _this5 = this;\n\n        if (!this.socket || this.socket.readyState !== this.socket.OPEN) {\n          var error = createEnigmaError(errorCodes.NOT_CONNECTED, 'Not connected');\n          return this.Promise.reject(error);\n        }\n\n        if (!data.id) {\n          data.id = this.createRequestId();\n        }\n\n        data.jsonrpc = '2.0';\n        return new this.Promise(function (resolve, reject) {\n          _this5.socket.send(JSON.stringify(data));\n\n          _this5.emit('traffic', 'sent', data, data.handle);\n\n          return _this5.registerResolver(data.id, data.handle, resolve, reject);\n        });\n      }\n    }, {\n      key: \"createRequestId\",\n      value: function createRequestId() {\n        this.requestId += 1;\n        return this.requestId;\n      }\n    }]);\n\n    return RPC;\n  }();\n\n  function _classCallCheck$3(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties$3(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass$3(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties$3(Constructor, staticProps);\n    return Constructor;\n  }\n\n  var ON_ATTACHED_TIMEOUT_MS = 5000;\n  var RPC_CLOSE_MANUAL_SUSPEND = 4000;\n\n  var SuspendResume = /*#__PURE__*/function () {\n    /**\n    * Creates a new SuspendResume instance.\n    * @private\n    * @param {Object} options The configuration option for this class.\n    * @param {Promise<Object>} options.Promise The promise constructor to use.\n    * @param {RPC} options.rpc The RPC instance to use when communicating towards Engine.\n    * @param {ApiCache} options.apis The ApiCache instance to use.\n    */\n    function SuspendResume(options) {\n      var _this = this;\n\n      _classCallCheck$3(this, SuspendResume);\n\n      Object.assign(this, options);\n      this.isSuspended = false;\n      this.rpc.on('traffic', function (dir, data) {\n        if (dir === 'sent' && data.method === 'OpenDoc') {\n          _this.openDocParams = data.params;\n        }\n      });\n    }\n    /**\n    * Function used to restore the rpc connection.\n    * @private\n    * @param {Boolean} onlyIfAttached - if true, the returned promise will resolve\n    *                                   only if the session can be re-attached.\n    * @returns {Object} Returns a promise instance.\n    */\n\n\n    _createClass$3(SuspendResume, [{\n      key: \"restoreRpcConnection\",\n      value: function restoreRpcConnection(onlyIfAttached) {\n        var _this2 = this;\n\n        return this.reopen(ON_ATTACHED_TIMEOUT_MS).then(function (sessionState) {\n          if (sessionState === 'SESSION_CREATED' && onlyIfAttached) {\n            return _this2.Promise.reject(createEnigmaError(errorCodes.SESSION_NOT_ATTACHED, 'Not attached'));\n          }\n\n          return _this2.Promise.resolve();\n        });\n      }\n      /**\n      * Function used to restore the global API.\n      * @private\n      * @param {Object} changed - A list where the restored APIs will be added.\n      * @returns {Object} Returns a promise instance.\n      */\n\n    }, {\n      key: \"restoreGlobal\",\n      value: function restoreGlobal(changed) {\n        var global = this.apis.getApisByType('Global').pop();\n        changed.push(global.api);\n        return this.Promise.resolve();\n      }\n      /**\n      * Function used to restore the doc API.\n      * @private\n      * @param {String} sessionState - The state of the session, attached or created.\n      * @param {Array} closed - A list where the closed of APIs APIs will be added.\n      * @param {Object} changed - A list where the restored APIs will be added.\n      * @returns {Object} Returns a promise instance.\n      */\n\n    }, {\n      key: \"restoreDoc\",\n      value: function restoreDoc(closed, changed) {\n        var _this3 = this;\n\n        var doc = this.apis.getApisByType('Doc').pop();\n\n        if (!doc) {\n          return this.Promise.resolve();\n        }\n\n        return this.rpc.send({\n          method: 'GetActiveDoc',\n          handle: -1,\n          params: []\n        }).then(function (response) {\n          if (response.error && _this3.openDocParams) {\n            return _this3.rpc.send({\n              method: 'OpenDoc',\n              handle: -1,\n              params: _this3.openDocParams\n            });\n          }\n\n          return response;\n        }).then(function (response) {\n          if (response.error) {\n            closed.push(doc.api);\n            return _this3.Promise.resolve();\n          }\n\n          var handle = response.result.qReturn.qHandle;\n          doc.api.handle = handle;\n          changed.push(doc.api);\n          return _this3.Promise.resolve(doc.api);\n        });\n      }\n      /**\n      * Function used to restore the APIs on the doc.\n      * @private\n      * @param {Object} doc - The doc API on which the APIs we want to restore exist.\n      * @param {Array} closed - A list where the closed of APIs APIs will be added.\n      * @param {Object} changed - A list where the restored APIs will be added.\n      * @returns {Object} Returns a promise instance.\n      */\n\n    }, {\n      key: \"restoreDocObjects\",\n      value: function restoreDocObjects(doc, closed, changed) {\n        var _this4 = this;\n\n        var tasks = [];\n        var apis = this.apis.getApis().map(function (entry) {\n          return entry.api;\n        }).filter(function (api) {\n          return api.type !== 'Global' && api.type !== 'Doc';\n        });\n\n        if (!doc) {\n          apis.forEach(function (api) {\n            return closed.push(api);\n          });\n          return this.Promise.resolve();\n        }\n\n        apis.forEach(function (api) {\n          var method = SuspendResume.buildGetMethodName(api.type);\n\n          if (!method) {\n            closed.push(api);\n          } else {\n            var request = _this4.rpc.send({\n              method: method,\n              handle: doc.handle,\n              params: [api.id]\n            }).then(function (response) {\n              if (response.error || !response.result.qReturn.qHandle) {\n                closed.push(api);\n              } else {\n                api.handle = response.result.qReturn.qHandle;\n                changed.push(api);\n              }\n            });\n\n            tasks.push(request);\n          }\n        });\n        return this.Promise.all(tasks);\n      }\n      /**\n      * Set the instance as suspended.\n      * @private\n      * @param {Number} [code=4000] - The reason code for suspending the connection.\n      * @param {String} [reason=\"\"] - The human readable string describing\n      * why the connection is suspended.\n      */\n\n    }, {\n      key: \"suspend\",\n      value: function suspend() {\n        var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RPC_CLOSE_MANUAL_SUSPEND;\n        var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n        this.isSuspended = true;\n        return this.rpc.close(code, reason);\n      }\n      /**\n      * Resumes a previously suspended RPC connection, and refreshes the API cache.\n      *                                APIs unabled to be restored has their 'closed'\n      *                                event triggered, otherwise 'changed'.\n      * @private\n      * @emits API#changed\n      * @emits APIfunction@#closed\n      * @param {Boolean} onlyIfAttached if true, resume only if the session was re-attached.\n      * @returns {Promise<Object>} Eventually resolved if the RPC connection was successfully resumed,\n      *                    otherwise rejected.\n      */\n\n    }, {\n      key: \"resume\",\n      value: function resume(onlyIfAttached) {\n        var _this5 = this;\n\n        var changed = [];\n        var closed = [];\n        return this.restoreRpcConnection(onlyIfAttached).then(function () {\n          return _this5.restoreGlobal(changed);\n        }).then(function () {\n          return _this5.restoreDoc(closed, changed);\n        }).then(function (doc) {\n          return _this5.restoreDocObjects(doc, closed, changed);\n        }).then(function () {\n          _this5.isSuspended = false;\n\n          _this5.apis.clear();\n\n          closed.forEach(function (api) {\n            api.emit('closed');\n            api.removeAllListeners();\n          });\n          changed.forEach(function (api) {\n            _this5.apis.add(api.handle, api);\n\n            if (api.type !== 'Global') {\n              api.emit('changed');\n            }\n          });\n        })[\"catch\"](function (err) {\n          return _this5.rpc.close().then(function () {\n            return _this5.Promise.reject(err);\n          });\n        });\n      }\n      /**\n      * Reopens the connection and waits for the OnConnected notification.\n      * @private\n      * @param {Number} timeout - The time to wait for the OnConnected notification.\n      * @returns {Object} A promise containing the session state (SESSION_CREATED or SESSION_ATTACHED).\n      */\n\n    }, {\n      key: \"reopen\",\n      value: function reopen(timeout) {\n        var _this6 = this;\n\n        var timer;\n        var notificationResolve;\n        var notificationReceived = false;\n        var notificationPromise = new this.Promise(function (resolve) {\n          notificationResolve = resolve;\n        });\n\n        var waitForNotification = function waitForNotification() {\n          if (!notificationReceived) {\n            timer = setTimeout(function () {\n              return notificationResolve('SESSION_CREATED');\n            }, timeout);\n          }\n\n          return notificationPromise;\n        };\n\n        var onNotification = function onNotification(data) {\n          if (data.method !== 'OnConnected') return;\n          clearTimeout(timer);\n          notificationResolve(data.params.qSessionState);\n          notificationReceived = true;\n        };\n\n        this.rpc.on('notification', onNotification);\n        return this.rpc.open(true).then(waitForNotification).then(function (state) {\n          _this6.rpc.removeListener('notification', onNotification);\n\n          return state;\n        })[\"catch\"](function (err) {\n          _this6.rpc.removeListener('notification', onNotification);\n\n          return _this6.Promise.reject(err);\n        });\n      }\n      /**\n      * Function used to build the get method names for Doc APIs.\n      * @private\n      * @param {String} type - The API type.\n      * @returns {String} Returns the get method name, or undefined if the type cannot be restored.\n      */\n\n    }], [{\n      key: \"buildGetMethodName\",\n      value: function buildGetMethodName(type) {\n        if (type === 'Field' || type === 'Variable') {\n          return null;\n        }\n\n        if (type === 'GenericVariable') {\n          return 'GetVariableById';\n        }\n\n        return type.replace('Generic', 'Get');\n      }\n    }]);\n\n    return SuspendResume;\n  }();\n\n  var SUCCESS_KEY = 'qSuccess';\n\n  function deltaRequestInterceptor(session, request) {\n    var delta = session.config.protocol.delta && request.outKey !== -1 && request.outKey !== SUCCESS_KEY;\n\n    if (delta) {\n      request.delta = delta;\n    }\n\n    return request;\n  }\n  /**\n  * Response interceptor for generating APIs. Handles the quirks of engine not\n  * returning an error when an object is missing.\n  * @private\n  * @param {Session} session - The session the intercept is being executed on.\n  * @param {Object} request - The JSON-RPC request.\n  * @param {Object} response - The response.\n  * @returns {Object} - Returns the generated API\n  */\n\n\n  function apiResponseInterceptor(session, request, response) {\n    if (response.qHandle && response.qType) {\n      return session.getObjectApi({\n        handle: response.qHandle,\n        type: response.qType,\n        id: response.qGenericId,\n        genericType: response.qGenericType\n      });\n    }\n\n    if (response.qHandle === null && response.qType === null) {\n      var error = createEnigmaError(errorCodes.OBJECT_NOT_FOUND, 'Object not found');\n      return session.config.Promise.reject(error);\n    }\n\n    return response;\n  }\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n  var toStr = Object.prototype.toString;\n  var defineProperty = Object.defineProperty;\n  var gOPD = Object.getOwnPropertyDescriptor;\n\n  var isArray$1 = function isArray(arr) {\n    if (typeof Array.isArray === 'function') {\n      return Array.isArray(arr);\n    }\n\n    return toStr.call(arr) === '[object Array]';\n  };\n\n  var isPlainObject = function isPlainObject(obj) {\n    if (!obj || toStr.call(obj) !== '[object Object]') {\n      return false;\n    }\n\n    var hasOwnConstructor = hasOwn.call(obj, 'constructor');\n    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf'); // Not own constructor property must be Object\n\n    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n      return false;\n    } // Own properties are enumerated firstly, so to speed up,\n    // if last one is own, then all properties are own.\n\n\n    var key;\n\n    for (key in obj) {\n      /**/\n    }\n\n    return typeof key === 'undefined' || hasOwn.call(obj, key);\n  }; // If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\n\n\n  var setProperty = function setProperty(target, options) {\n    if (defineProperty && options.name === '__proto__') {\n      defineProperty(target, options.name, {\n        enumerable: true,\n        configurable: true,\n        value: options.newValue,\n        writable: true\n      });\n    } else {\n      target[options.name] = options.newValue;\n    }\n  }; // Return undefined instead of __proto__ if '__proto__' is not an own property\n\n\n  var getProperty = function getProperty(obj, name) {\n    if (name === '__proto__') {\n      if (!hasOwn.call(obj, name)) {\n        return void 0;\n      } else if (gOPD) {\n        // In early versions of node, obj['__proto__'] is buggy when obj has\n        // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n        return gOPD(obj, name).value;\n      }\n    }\n\n    return obj[name];\n  };\n\n  var extend$1 = function extend() {\n    var options, name, src, copy, copyIsArray, clone;\n    var target = arguments[0];\n    var i = 1;\n    var length = arguments.length;\n    var deep = false; // Handle a deep copy situation\n\n    if (typeof target === 'boolean') {\n      deep = target;\n      target = arguments[1] || {}; // skip the boolean and the target\n\n      i = 2;\n    }\n\n    if (target == null || typeof target !== 'object' && typeof target !== 'function') {\n      target = {};\n    }\n\n    for (; i < length; ++i) {\n      options = arguments[i]; // Only deal with non-null/undefined values\n\n      if (options != null) {\n        // Extend the base object\n        for (name in options) {\n          src = getProperty(target, name);\n          copy = getProperty(options, name); // Prevent never-ending loop\n\n          if (target !== copy) {\n            // Recurse if we're merging plain objects or arrays\n            if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray$1(copy)))) {\n              if (copyIsArray) {\n                copyIsArray = false;\n                clone = src && isArray$1(src) ? src : [];\n              } else {\n                clone = src && isPlainObject(src) ? src : {};\n              } // Never move original objects, clone them\n\n\n              setProperty(target, {\n                name: name,\n                newValue: extend(deep, clone, copy)\n              }); // Don't bring in undefined values\n            } else if (typeof copy !== 'undefined') {\n              setProperty(target, {\n                name: name,\n                newValue: copy\n              });\n            }\n          }\n        }\n      }\n    } // Return the modified object\n\n\n    return target;\n  };\n\n  function _toConsumableArray$1(arr) {\n    return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();\n  }\n\n  function _nonIterableSpread$1() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function _unsupportedIterableToArray$1(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);\n  }\n\n  function _iterableToArray$1(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n  }\n\n  function _arrayWithoutHoles$1(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);\n  }\n\n  function _arrayLikeToArray$1(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n\n  function _typeof$2(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof$2 = function _typeof(obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof$2 = function _typeof(obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof$2(obj);\n  }\n\n  var extend = extend$1.bind(null, true);\n  var JSONPatch = {};\n  var isArray = Array.isArray;\n\n  function isObject(v) {\n    return v != null && !Array.isArray(v) && _typeof$2(v) === 'object';\n  }\n\n  function isUndef(v) {\n    return typeof v === 'undefined';\n  }\n\n  function isFunction(v) {\n    return typeof v === 'function';\n  }\n  /**\n  * Generate an exact duplicate (with no references) of a specific value.\n  *\n  * @private\n  * @param {Object} The value to duplicate\n  * @returns {Object} a unique, duplicated value\n  */\n\n\n  function generateValue(val) {\n    if (val) {\n      return extend({}, {\n        val: val\n      }).val;\n    }\n\n    return val;\n  }\n  /**\n  * An additional type checker used to determine if the property is of internal\n  * use or not a type that can be translated into JSON (like functions).\n  *\n  * @private\n  * @param {Object} obj The object which has the property to check\n  * @param {String} The property name to check\n  * @returns {Boolean} Whether the property is deemed special or not\n  */\n\n\n  function isSpecialProperty(obj, key) {\n    return isFunction(obj[key]) || key.substring(0, 2) === '$$' || key.substring(0, 1) === '_';\n  }\n  /**\n  * Finds the parent object from a JSON-Pointer (\"/foo/bar/baz\" = \"bar\" is \"baz\" parent),\n  * also creates the object structure needed.\n  *\n  * @private\n  * @param {Object} data The root object to traverse through\n  * @param {String} The JSON-Pointer string to use when traversing\n  * @returns {Object} The parent object\n  */\n\n\n  function getParent(data, str) {\n    var seperator = '/';\n    var parts = str.substring(1).split(seperator).slice(0, -1);\n    var numPart;\n    parts.forEach(function (part, i) {\n      if (i === parts.length) {\n        return;\n      }\n\n      numPart = +part;\n      var newPart = !isNaN(numPart) ? [] : {};\n      data[numPart || part] = isUndef(data[numPart || part]) ? newPart : data[part];\n      data = data[numPart || part];\n    });\n    return data;\n  }\n  /**\n  * Cleans an object of all its properties, unless they're deemed special or\n  * cannot be removed by configuration.\n  *\n  * @private\n  * @param {Object} obj The object to clean\n  */\n\n\n  function emptyObject(obj) {\n    Object.keys(obj).forEach(function (key) {\n      var config = Object.getOwnPropertyDescriptor(obj, key);\n\n      if (config.configurable && !isSpecialProperty(obj, key)) {\n        delete obj[key];\n      }\n    });\n  }\n  /**\n  * Compare an object with another, could be object, array, number, string, bool.\n  * @private\n  * @param {Object} a The first object to compare\n  * @param {Object} a The second object to compare\n  * @returns {Boolean} Whether the objects are identical\n  */\n\n\n  function compare(a, b) {\n    var isIdentical = true;\n\n    if (isObject(a) && isObject(b)) {\n      if (Object.keys(a).length !== Object.keys(b).length) {\n        return false;\n      }\n\n      Object.keys(a).forEach(function (key) {\n        if (!compare(a[key], b[key])) {\n          isIdentical = false;\n        }\n      });\n      return isIdentical;\n    }\n\n    if (isArray(a) && isArray(b)) {\n      if (a.length !== b.length) {\n        return false;\n      }\n\n      for (var i = 0, l = a.length; i < l; i += 1) {\n        if (!compare(a[i], b[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return a === b;\n  }\n  /**\n  * Generates patches by comparing two arrays.\n  *\n  * @private\n  * @param {Array} oldA The old (original) array, which will be patched\n  * @param {Array} newA The new array, which will be used to compare against\n  * @returns {Array} An array of patches (if any)\n  */\n\n\n  function patchArray(original, newA, basePath) {\n    var patches = [];\n    var oldA = original.slice();\n    var tmpIdx = -1;\n\n    function findIndex(a, id, idx) {\n      if (a[idx] && isUndef(a[idx].qInfo)) {\n        return null;\n      }\n\n      if (a[idx] && a[idx].qInfo.qId === id) {\n        // shortcut if identical\n        return idx;\n      }\n\n      for (var ii = 0, ll = a.length; ii < ll; ii += 1) {\n        if (a[ii] && a[ii].qInfo.qId === id) {\n          return ii;\n        }\n      }\n\n      return -1;\n    }\n\n    if (compare(newA, oldA)) {\n      // array is unchanged\n      return patches;\n    }\n\n    if (!isUndef(newA[0]) && isUndef(newA[0].qInfo)) {\n      // we cannot create patches without unique identifiers, replace array...\n      patches.push({\n        op: 'replace',\n        path: basePath,\n        value: newA\n      });\n      return patches;\n    }\n\n    for (var i = oldA.length - 1; i >= 0; i -= 1) {\n      tmpIdx = findIndex(newA, oldA[i].qInfo && oldA[i].qInfo.qId, i);\n\n      if (tmpIdx === -1) {\n        patches.push({\n          op: 'remove',\n          path: \"\".concat(basePath, \"/\").concat(i)\n        });\n        oldA.splice(i, 1);\n      } else {\n        patches = patches.concat(JSONPatch.generate(oldA[i], newA[tmpIdx], \"\".concat(basePath, \"/\").concat(i)));\n      }\n    }\n\n    for (var _i = 0, l = newA.length; _i < l; _i += 1) {\n      tmpIdx = findIndex(oldA, newA[_i].qInfo && newA[_i].qInfo.qId);\n\n      if (tmpIdx === -1) {\n        patches.push({\n          op: 'add',\n          path: \"\".concat(basePath, \"/\").concat(_i),\n          value: newA[_i]\n        });\n        oldA.splice(_i, 0, newA[_i]);\n      } else if (tmpIdx !== _i) {\n        patches.push({\n          op: 'move',\n          path: \"\".concat(basePath, \"/\").concat(_i),\n          from: \"\".concat(basePath, \"/\").concat(tmpIdx)\n        });\n        oldA.splice(_i, 0, oldA.splice(tmpIdx, 1)[0]);\n      }\n    }\n\n    return patches;\n  }\n  /**\n  * Generate an array of JSON-Patch:es following the JSON-Patch Specification Draft.\n  *\n  * See [specification draft](http://tools.ietf.org/html/draft-ietf-appsawg-json-patch-10)\n  *\n  * Does NOT currently generate patches for arrays (will replace them)\n  * @private\n  * @param {Object} original The object to patch to\n  * @param {Object} newData The object to patch from\n  * @param {String} [basePath] The base path to use when generating the paths for\n  *                            the patches (normally not used)\n  * @returns {Array} An array of patches\n  */\n\n\n  JSONPatch.generate = function generate(original, newData, basePath) {\n    basePath = basePath || '';\n    var patches = [];\n    Object.keys(newData).forEach(function (key) {\n      var val = generateValue(newData[key]);\n      var oldVal = original[key];\n      var tmpPath = \"\".concat(basePath, \"/\").concat(key);\n\n      if (compare(val, oldVal) || isSpecialProperty(newData, key)) {\n        return;\n      }\n\n      if (isUndef(oldVal)) {\n        // property does not previously exist\n        patches.push({\n          op: 'add',\n          path: tmpPath,\n          value: val\n        });\n      } else if (isObject(val) && isObject(oldVal)) {\n        // we need to generate sub-patches for this, since it already exist\n        patches = patches.concat(JSONPatch.generate(oldVal, val, tmpPath));\n      } else if (isArray(val) && isArray(oldVal)) {\n        patches = patches.concat(patchArray(oldVal, val, tmpPath));\n      } else {\n        // it's a simple property (bool, string, number)\n        patches.push({\n          op: 'replace',\n          path: \"\".concat(basePath, \"/\").concat(key),\n          value: val\n        });\n      }\n    });\n    Object.keys(original).forEach(function (key) {\n      if (isUndef(newData[key]) && !isSpecialProperty(original, key)) {\n        // this property does not exist anymore\n        patches.push({\n          op: 'remove',\n          path: \"\".concat(basePath, \"/\").concat(key)\n        });\n      }\n    });\n    return patches;\n  };\n  /**\n  * Apply a list of patches to an object.\n  * @private\n  * @param {Object} original The object to patch\n  * @param {Array} patches The list of patches to apply\n  */\n\n\n  JSONPatch.apply = function apply(original, patches) {\n    patches.forEach(function (patch) {\n      var parent = getParent(original, patch.path);\n      var key = patch.path.split('/').splice(-1)[0];\n      var target = key && isNaN(+key) ? parent[key] : parent[+key] || parent;\n      var from = patch.from ? patch.from.split('/').splice(-1)[0] : null;\n\n      if (patch.path === '/') {\n        parent = null;\n        target = original;\n      }\n\n      if (patch.op === 'add' || patch.op === 'replace') {\n        if (isArray(parent)) {\n          // trust indexes from patches, so don't replace the index if it's an add\n          if (key === '-') {\n            key = parent.length;\n          }\n\n          parent.splice(+key, patch.op === 'add' ? 0 : 1, patch.value);\n        } else if (isArray(target) && isArray(patch.value)) {\n          // keep array reference if possible...\n          target.length = 0;\n          var chunkSize = 1000;\n\n          for (var i = 0; i < patch.value.length; i += chunkSize) {\n            var _target;\n\n            var chunk = patch.value.slice(i, i + chunkSize);\n\n            (_target = target).push.apply(_target, _toConsumableArray$1(chunk));\n          }\n        } else if (isObject(target) && isObject(patch.value)) {\n          // keep object reference if possible...\n          emptyObject(target);\n          extend(target, patch.value);\n        } else if (!parent) {\n          throw createEnigmaError(errorCodes.PATCH_HAS_NO_PARENT, 'Patchee is not an object we can patch');\n        } else {\n          // simple value\n          parent[key] = patch.value;\n        }\n      } else if (patch.op === 'move') {\n        var oldParent = getParent(original, patch.from);\n\n        if (isArray(parent)) {\n          parent.splice(+key, 0, oldParent.splice(+from, 1)[0]);\n        } else {\n          parent[key] = oldParent[from];\n          delete oldParent[from];\n        }\n      } else if (patch.op === 'remove') {\n        if (isArray(parent)) {\n          parent.splice(+key, 1);\n        } else {\n          delete parent[key];\n        }\n      }\n    });\n  };\n  /**\n  * Deep clone an object.\n  * @private\n  * @param {Object} obj The object to clone\n  * @returns {Object} A new object identical to the `obj`\n  */\n\n\n  JSONPatch.clone = function clone(obj) {\n    return extend({}, obj);\n  };\n  /**\n  * Creates a JSON-patch.\n  * @private\n  * @param {String} op The operation of the patch. Available values: \"add\", \"remove\", \"move\"\n  * @param {Object} [val] The value to set the `path` to. If `op` is `move`, `val`\n  *                       is the \"from JSON-path\" path\n  * @param {String} path The JSON-path for the property to change (e.g. \"/qHyperCubeDef/columnOrder\")\n  * @returns {Object} A patch following the JSON-patch specification\n  */\n\n\n  JSONPatch.createPatch = function createPatch(op, val, path) {\n    var patch = {\n      op: op.toLowerCase(),\n      path: path\n    };\n\n    if (patch.op === 'move') {\n      patch.from = val;\n    } else if (typeof val !== 'undefined') {\n      patch.value = val;\n    }\n\n    return patch;\n  };\n  /**\n  * Apply the differences of two objects (keeping references if possible).\n  * Identical to running `JSONPatch.apply(original, JSONPatch.generate(original, newData));`\n  * @private\n  * @param {Object} original The object to update/patch\n  * @param {Object} newData the object to diff against\n  *\n  * @example\n  * var obj1 = { foo: [1,2,3], bar: { baz: true, qux: 1 } };\n  * var obj2 = { foo: [4,5,6], bar: { baz: false } };\n  * JSONPatch.updateObject(obj1, obj2);\n  * // => { foo: [4,5,6], bar: { baz: false } };\n  */\n\n\n  JSONPatch.updateObject = function updateObject(original, newData) {\n    if (!Object.keys(original).length) {\n      extend(original, newData);\n      return;\n    }\n\n    JSONPatch.apply(original, JSONPatch.generate(original, newData));\n  };\n\n  function _typeof$1(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof$1 = function _typeof(obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof$1 = function _typeof(obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof$1(obj);\n  }\n\n  var sessions = {};\n  /**\n  * Function to make sure we release handle caches when they are closed.\n  * @private\n  * @param {Session} session The session instance to listen on.\n  */\n\n  var bindSession = function bindSession(session) {\n    if (!sessions[session.id]) {\n      var cache = {};\n      sessions[session.id] = cache;\n      session.on('traffic:received', function (data) {\n        return data.close && data.close.forEach(function (handle) {\n          return delete cache[handle];\n        });\n      });\n      session.on('closed', function () {\n        return delete sessions[session.id];\n      });\n    }\n  };\n  /**\n  * Simple function that ensures the session events has been bound, and returns\n  * either an existing key-value cache or creates one for the specified handle.\n  * @private\n  * @param {Session} session The session that owns the handle.\n  * @param {Number} handle The object handle to retrieve the cache for.\n  * @returns {KeyValueCache} The cache instance.\n  */\n\n\n  var getHandleCache = function getHandleCache(session, handle) {\n    bindSession(session);\n    var cache = sessions[session.id];\n\n    if (!cache[handle]) {\n      cache[handle] = new KeyValueCache();\n    }\n\n    return cache[handle];\n  };\n  /**\n  * Function used to apply a list of patches and return the patched value.\n  * @private\n  * @param {Session} session The session.\n  * @param {Number} handle The object handle.\n  * @param {String} cacheId The cacheId.\n  * @param {Array} patches The patches.\n  * @returns {Object} Returns the patched value.\n  */\n\n\n  var patchValue = function patchValue(session, handle, cacheId, patches) {\n    var cache = getHandleCache(session, handle);\n    var entry = cache.get(cacheId);\n\n    if (typeof entry === 'undefined') {\n      entry = Array.isArray(patches[0].value) ? [] : {};\n    }\n\n    if (patches.length) {\n      if (patches[0].path === '/' && _typeof$1(patches[0].value) !== 'object') {\n        // 'plain' values on root path is not supported (no object reference),\n        // so we simply store the value directly:\n        entry = patches[0].value;\n      } else {\n        JSONPatch.apply(entry, patches);\n      }\n\n      cache.set(cacheId, entry);\n    }\n\n    return entry;\n  };\n  /**\n  * Process delta interceptor.\n  * @private\n  * @param {Session} session The session the intercept is being executed on.\n  * @param {Object} request The JSON-RPC request.\n  * @param {Object} response The response.\n  * @returns {Object} Returns the patched response\n  */\n\n\n  function deltaResponseInterceptor(session, request, response) {\n    var delta = response.delta,\n        result = response.result;\n\n    if (delta) {\n      // when delta is on the response data is expected to be an array of patches:\n      Object.keys(result).forEach(function (key) {\n        if (!Array.isArray(result[key])) {\n          throw createEnigmaError(errorCodes.EXPECTED_ARRAY_OF_PATCHES, 'Unexpected RPC response, expected array of patches');\n        }\n\n        result[key] = patchValue(session, request.handle, \"\".concat(request.method, \"-\").concat(key), result[key]);\n      }); // return a cloned response object to avoid patched object references:\n\n      return JSON.parse(JSON.stringify(response));\n    }\n\n    return response;\n  } // export object reference for testing purposes:\n\n\n  deltaResponseInterceptor.sessions = sessions;\n  /**\n  * Process error interceptor.\n  * @private\n  * @param {Session} session - The session the intercept is being executed on.\n  * @param {Object} request - The JSON-RPC request.\n  * @param {Object} response - The response.\n  * @returns {Object} - Returns the defined error for an error, else the response.\n  */\n\n  function errorResponseInterceptor(session, request, response) {\n    if (typeof response.error !== 'undefined') {\n      var data = response.error;\n      var error = new Error(data.message);\n      error.code = data.code;\n      error.parameter = data.parameter;\n      return session.config.Promise.reject(error);\n    }\n\n    return response;\n  }\n\n  var RETURN_KEY = 'qReturn';\n  /**\n  * Picks out the result \"out\" parameter based on the QIX method+schema, with\n  * some specific handling for some methods that breaks the predictable protocol.\n  * @private\n  * @param {Session} session - The session the intercept is being executed on.\n  * @param {Object} request - The JSON-RPC request.\n  * @param {Object} response - The response.\n  * @returns {Object} - Returns the result property on the response\n  */\n\n  function outParamResponseInterceptor(session, request, response) {\n    if (request.method === 'CreateSessionApp' || request.method === 'CreateSessionAppFromApp') {\n      // this method returns multiple out params that we need\n      // to normalize before processing the response further:\n      response[RETURN_KEY].qGenericId = response.qSessionAppId || response[RETURN_KEY].qGenericId;\n    } else if (request.method === 'GetInteract') {\n      // this method returns a qReturn value when it should only return\n      // meta.outKey:\n      delete response[RETURN_KEY];\n    }\n\n    if (hasOwnProperty.call(response, RETURN_KEY)) {\n      return response[RETURN_KEY];\n    }\n\n    if (request.outKey !== -1) {\n      return response[request.outKey];\n    }\n\n    return response;\n  }\n  /**\n  * Process result interceptor.\n  * @private\n  * @param {Session} session - The session the intercept is being executed on.\n  * @param {Object} request - The JSON-RPC request.\n  * @param {Object} response - The response.\n  * @returns {Object} - Returns the result property on the response\n  */\n\n\n  function resultResponseInterceptor(session, request, response) {\n    return response.result;\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n\n  function _classCallCheck$2(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties$2(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass$2(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties$2(Constructor, staticProps);\n    return Constructor;\n  }\n  /**\n   * Interceptor is a concept similar to mixins, but runs on a lower level. The interceptor concept\n   * can augment either the requests (i.e. before sent to QIX Engine), or the responses (i.e. after\n   * QIX Engine has sent a response). The interceptor promises run in parallel to the regular\n   * promises used in enigma.js, which means that it can be really useful when you want to normalize\n   * behaviors in your application.\n   * @interface Interceptor\n   */\n\n  /**\n   * @class InterceptorRequest\n   * @implements {Interceptor}\n   * @example <caption>Implement a request interceptor</caption>\n   * const enigma = require('enigma.js');\n   * const WebSocket = require('ws');\n   * const schema = require('enigma.js/schemas/12.20.0.json');\n   *\n   * const session = enigma.create({\n   *   schema,\n   *   url: 'ws://localhost:9076/app/engineData',\n   *   createSocket: (url) => new WebSocket(url),\n   *   requestInterceptors: [{\n   *     onFulfilled: function logRequest(sessionReference, request) {\n   *       console.log('Request being sent', request);\n   *       return request;\n   *     }\n   *   },\n   * });\n   */\n\n  /**\n   * @class InterceptorResponse\n   * @implements {Interceptor}\n   * @example <caption>Implement a request interceptor</caption>\n   * const enigma = require('enigma.js');\n   * const WebSocket = require('ws');\n   * const schema = require('enigma.js/schemas/12.20.0.json');\n   *\n   * const session = enigma.create({\n   *   schema,\n   *   url: 'ws://localhost:9076/app/engineData',\n   *   createSocket: (url) => new WebSocket(url),\n   *   responseInterceptors: [{\n   *     onRejected: function logError(sessionReference, request, error) {\n   *       console.log('Error returned from QIX engine', error, 'Originating request:', request);\n   *       // throw error so it's continued to be rejected:\n   *       throw error;\n   *     }\n   *   },\n   * });\n   */\n\n  /**\n   * This method is invoked when a request is about to be sent to QIX Engine.\n   * @function InterceptorRequest#onFulfilled\n   * @param {Session} session The session executing the interceptor.\n   * @param {Object} request The JSON-RPC request that will be sent.\n   */\n\n  /**\n   * This method is invoked when a previous interceptor has rejected the\n   * promise; use this to handle, for example, errors before they are sent into mixins.\n   * @function InterceptorResponse#onRejected\n   * @param {Session} session The session executing the interceptor. You may use .retry() to retry\n   * sending it to QIX Engine.\n   * @param {Object} request The JSON-RPC request resulting in this error.\n   * @param {Object} error Whatever the previous interceptor is rejected with.\n   */\n\n  /**\n   * This method is invoked when a promise has been successfully resolved;\n   * use this to modify the result or reject the promise chain before it is sent\n   * to mixins.\n   * @function InterceptorResponse#onFulfilled\n   * @param {Session} session The session executing the interceptor.\n   * @param {Object} request The JSON-RPC request resulting in this response.\n   * @param {Object} result Whatever the previous interceptor is resolved with.\n   */\n\n\n  var Intercept = /*#__PURE__*/function () {\n    /**\n    * Create a new Intercept instance.\n    * @private\n    * @param {Object} options The configuration options for this class.\n    * @param {Promise<Object>} options.Promise The promise constructor to use.\n    * @param {ApiCache} options.apis The ApiCache instance to use.\n    * @param {Array<Object>} [options.request] The additional request interceptors to use.\n    * @param {Array<Object>} [options.response] The additional response interceptors to use.\n    */\n    function Intercept(options) {\n      _classCallCheck$2(this, Intercept);\n\n      Object.assign(this, options);\n      this.request = [{\n        onFulfilled: deltaRequestInterceptor\n      }].concat(_toConsumableArray(this.request || []));\n      this.response = [{\n        onFulfilled: errorResponseInterceptor\n      }, {\n        onFulfilled: deltaResponseInterceptor\n      }, {\n        onFulfilled: resultResponseInterceptor\n      }, {\n        onFulfilled: outParamResponseInterceptor\n      }].concat(_toConsumableArray(this.response || []), [{\n        onFulfilled: apiResponseInterceptor\n      }]);\n    }\n    /**\n    * Execute the request interceptor queue, each interceptor will get the result from\n    * the previous interceptor.\n    * @private\n    * @param {Session} session The session instance to execute against.\n    * @param {Promise<Object>} promise The promise to chain on to.\n    * @returns {Promise<Object>}\n    */\n\n\n    _createClass$2(Intercept, [{\n      key: \"executeRequests\",\n      value: function executeRequests(session, promise) {\n        var _this = this;\n\n        return this.request.reduce(function (interception, interceptor) {\n          var intercept = interceptor.onFulfilled && interceptor.onFulfilled.bind(_this, session);\n          return interception.then(intercept);\n        }, promise);\n      }\n      /**\n      * Execute the response interceptor queue, each interceptor will get the result from\n      * the previous interceptor.\n      * @private\n      * @param {Session} session The session instance to execute against.\n      * @param {Promise<Object>} promise The promise to chain on to.\n      * @param {Object} request The JSONRPC request object for the intercepted response.\n      * @returns {Promise<Object>}\n      */\n\n    }, {\n      key: \"executeResponses\",\n      value: function executeResponses(session, promise, request) {\n        var _this2 = this;\n\n        return this.response.reduce(function (interception, interceptor) {\n          return interception.then(interceptor.onFulfilled && interceptor.onFulfilled.bind(_this2, session, request), interceptor.onRejected && interceptor.onRejected.bind(_this2, session, request));\n        }, promise);\n      }\n    }]);\n\n    return Intercept;\n  }();\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function _typeof(obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function _typeof(obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck$1(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties$1(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass$1(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties$1(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _get(target, property, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = _superPropBase(target, property);\n\n        if (!base) return;\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n\n    return _get(target, property, receiver || target);\n  }\n\n  function _superPropBase(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = _getPrototypeOf(object);\n      if (object === null) break;\n    }\n\n    return object;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n    return function _createSuperInternal() {\n      var Super = _getPrototypeOf(Derived),\n          result;\n\n      if (hasNativeReflectConstruct) {\n        var NewTarget = _getPrototypeOf(this).constructor;\n\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n\n      return _possibleConstructorReturn(this, result);\n    };\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n  /**\n  * API cache for instances of QIX types, e.g. GenericObject.\n  * @private\n  * @extends KeyValueCache\n  */\n\n\n  var ApiCache = /*#__PURE__*/function (_KeyValueCache) {\n    _inherits(ApiCache, _KeyValueCache);\n\n    var _super = _createSuper(ApiCache);\n\n    function ApiCache() {\n      _classCallCheck$1(this, ApiCache);\n\n      return _super.apply(this, arguments);\n    }\n\n    _createClass$1(ApiCache, [{\n      key: \"add\",\n      value:\n      /**\n      * Adds an API.\n      * @private\n      * @function ApiCache#add\n      * @param {Number} handle - The handle for the API.\n      * @param {*} api - The API.\n      * @returns {{api: *}} The entry.\n      */\n      function add(handle, api) {\n        var _this = this;\n\n        var entry = {\n          api: api\n        };\n\n        _get(_getPrototypeOf(ApiCache.prototype), \"add\", this).call(this, handle.toString(), entry);\n\n        api.on('closed', function () {\n          return _this.remove(handle);\n        });\n        return entry;\n      }\n      /**\n      * Gets an API.\n      * @private\n      * @function ApiCache#getApi\n      * @param {Number} handle - The handle for the API.\n      * @returns {*} The API for the handle.\n      */\n\n    }, {\n      key: \"getApi\",\n      value: function getApi(handle) {\n        var entry = typeof handle !== 'undefined' ? this.get(handle.toString()) : undefined;\n        return entry && entry.api;\n      }\n      /**\n      * Gets a list of APIs.\n      * @private\n      * @function ApiCache#getApis\n      * @returns {Array} The list of entries including `handle` and `api` properties for each entry.\n      */\n\n    }, {\n      key: \"getApis\",\n      value: function getApis() {\n        return _get(_getPrototypeOf(ApiCache.prototype), \"getAll\", this).call(this).map(function (entry) {\n          return {\n            handle: entry.key,\n            api: entry.value.api\n          };\n        });\n      }\n      /**\n      * Gets a list of APIs with a given type.\n      * @private\n      * @function ApiCache#getApisByType\n      * @param {String} type - The type of APIs to get.\n      * @returns {Array} The list of entries including `handle` and `api` properties for each entry.\n      */\n\n    }, {\n      key: \"getApisByType\",\n      value: function getApisByType(type) {\n        return this.getApis().filter(function (entry) {\n          return entry.api.type === type;\n        });\n      }\n    }]);\n\n    return ApiCache;\n  }(KeyValueCache);\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n  /**\n   * The enigma.js configuration object.\n   * @interface Configuration\n   * @property {Object} schema Object containing the specification for the API to generate.\n   * Corresponds to a specific version of the QIX Engine API.\n   * @property {String} url String containing a proper websocket URL to QIX Engine.\n   * @property {Function} [createSocket] A function to use when instantiating the WebSocket,\n   * mandatory for Node.js.\n   * @property {Object} [Promise] ES6-compatible Promise library.\n   * @property {Boolean} [suspendOnClose=false] Set to true if the session should be suspended\n   * instead of closed when the websocket is closed.\n   * @property {Array<Mixin>} [mixins=[]] Mixins to extend/augment the QIX Engine API. Mixins\n   * are applied in the array order.\n   * @property {Array} [requestInterceptors=[]] Interceptors for augmenting requests before they\n   * are sent to QIX Engine. Interceptors are applied in the array order.\n   * @property {Array} [responseInterceptors=[]] Interceptors for augmenting responses before they\n   * are passed into mixins and end-users. Interceptors are applied in the array order.\n   * @property {Object} [protocol={}] An object containing additional JSON-RPC request parameters.\n   * @property {Boolean} [protocol.delta=true] Set to false to disable the use of the\n   * bandwidth-reducing delta protocol.\n   * @example <caption>Example defining a configuration object</caption>\n   * const enigma = require('enigma.js');\n   * const WebSocket = require('ws');\n   * const bluebird = require('bluebird');\n   * const schema = require('enigma.js/schemas/12.20.0.json');\n   *\n   * const config = {\n   *  schema,\n   *  url: 'ws://localhost:4848/app/engineData',\n   *  createSocket: url => new WebSocket(url),\n   *  Promise: bluebird,\n   *  suspendOnClose: true,\n   *  mixins: [{ types: ['Global'], init: () => console.log('Mixin ran') }],\n   *  protocol: { delta: false },\n   * };\n   *\n   * enigma.create(config).open().then((global) => {\n   *   // global === QIX global interface\n   *   process.exit(0);\n   * });\n   */\n\n  /**\n   * The mixin concept allows you to add or override QIX Engine API functionality. A mixin is\n   * basically a JavaScript object describing which types it modifies, and a list of functions\n   * for extending and overriding the API for those types.\n   *\n   * QIX Engine types like, for example, GenericObject, Doc, GenericBookmark, are supported but\n   * also custom GenericObject types such as barchart, story and myCustomType. An API will get\n   * both their generic type as well as custom type mixins applied.\n   *\n   * Mixins that are bound to several different types can find the current API type in the\n   * `genericType` or `type` members. `this.type` would, for instance, return `GenericObject` and\n   * `this.genericType` would return `barchart`.\n   *\n   * See the Mixins examples on how to use it. Below is an outline of what the mixin API consists of.\n   *\n   * @interface Mixin\n   * @property {String|Array<String>} types String or array of strings containing the API-types that\n   * will be mixed in.\n   * @property {Object} [extend] Object literal containing the methods that will be extended on the\n   * specified API.\n   * @property {Object} [override] Object literal containing the methods to override existing methods.\n   * @property {Function} [init] Init function that, if defined, will run when an API is instantiated.\n   * It runs with Promise and API object as parameters.\n   */\n\n  /**\n   * The API for generated APIs depends on the QIX Engine schema you pass into your Configuration, and\n   * on what QIX struct the API has.\n   *\n   * All API calls made using the generated APIs will return promises that are either resolved or\n   * rejected depending on how the QIX Engine responds.\n   *\n   * @interface API\n   * @property {String} id Contains the unique identifier for this API.\n   * @property {String} type Contains the schema class name for this API.\n   * @property {String} genericType Corresponds to the qInfo.qType property on the generic object's\n   * properties object.\n   * @property {Session} session Contains a reference to the session that this API belongs to.\n   * @property {Number} handle Contains the handle QIX Engine assigned to the API. Used interally in\n   * enigma.js for caches and JSON-RPC requests.\n   * @example <caption>Example using `global` and `generic object` struct APIs</caption>\n   * global.openDoc('my-document.qvf').then((doc) => {\n   *   doc.createObject({ qInfo: { qType: 'my-object' } }).then(api => { });\n   *   doc.getObject('object-id').then(api => { });\n   *   doc.getBookmark('bookmark-id').then(api => { });\n   * });\n   */\n\n  /**\n   * Handles changes on the API. The changed event is triggered whenever enigma.js or QIX Engine has\n   * identified potential changes on the underlying properties or hypercubes and you should re-fetch\n   * your data.\n   * @event API#changed\n   * @type {Object}\n   * @example <caption>Bind the `changed` event</caption>\n   * api.on('changed', () => {\n   *   api.getLayout().then(layout => { });\n   * });\n   */\n\n  /**\n   * Handles closed API. The closed event is triggered whenever QIX Engine considers an API closed.\n   * It usually means that it no longer exists in the QIX Engine document or session.\n   * @event API#closed\n   * @type {Object}\n   * @example <caption>Bind the `closed` event</caption>\n   * api.on('closed', () => {\n   *   console.log(api.id, 'was closed');\n   * });\n   */\n\n  /**\n   * Handles JSON-RPC requests/responses for this API. Generally used in debugging purposes.\n   * `traffic:*` will handle all websocket messages, `traffic:sent` will handle outgoing messages\n   * and `traffic:received` will handle incoming messages.\n   * @event API#traffic\n   * @type {Object}\n   * @example <caption>Bind the traffic events</caption>\n   * // bind both in- and outbound traffic to console.log:\n   * api.on('traffic:*', console.log);\n   * // bind outbound traffic to console.log:\n   * api.on('traffic:sent', console.log);\n   * // bind inbound traffic to console.log:\n   * api.on('traffic:received', console.log);\n   */\n\n\n  var Enigma = /*#__PURE__*/function () {\n    function Enigma() {\n      _classCallCheck(this, Enigma);\n    }\n\n    _createClass(Enigma, null, [{\n      key: \"getSession\",\n      value:\n      /**\n       * Function used to get a session.\n       * @private\n       * @param {Configuration} config The configuration object for this session.\n       * @returns {Session} Returns a session instance.\n       */\n      function getSession(config) {\n        var createSocket = config.createSocket,\n            Promise = config.Promise,\n            requestInterceptors = config.requestInterceptors,\n            responseInterceptors = config.responseInterceptors,\n            url = config.url;\n        var apis = new ApiCache();\n        var intercept = new Intercept({\n          apis: apis,\n          Promise: Promise,\n          request: requestInterceptors,\n          response: responseInterceptors\n        });\n        var rpc = new RPC({\n          createSocket: createSocket,\n          Promise: Promise,\n          url: url\n        });\n        var suspendResume = new SuspendResume({\n          apis: apis,\n          Promise: Promise,\n          rpc: rpc\n        });\n        var session = new Session({\n          apis: apis,\n          config: config,\n          intercept: intercept,\n          rpc: rpc,\n          suspendResume: suspendResume\n        });\n        return session;\n      }\n      /**\n      * Function used to configure defaults.\n      * @private\n      * @param {Configuration} config The configuration object for how to connect\n      *                               and retrieve end QIX APIs.\n      */\n\n    }, {\n      key: \"configureDefaults\",\n      value: function configureDefaults(config) {\n        if (!config) {\n          throw createEnigmaError(errorCodes.NO_CONFIG_SUPPLIED, 'You need to supply a configuration.');\n        } // eslint-disable-next-line no-restricted-globals\n\n\n        if (!config.Promise && typeof Promise === 'undefined') {\n          throw createEnigmaError(errorCodes.PROMISE_REQUIRED, 'Your environment has no Promise implementation. You must provide a Promise implementation in the config.');\n        }\n\n        if (typeof config.createSocket !== 'function' && typeof WebSocket === 'function') {\n          // eslint-disable-next-line no-undef\n          config.createSocket = function (url) {\n            return new WebSocket(url);\n          };\n        }\n\n        if (typeof config.suspendOnClose === 'undefined') {\n          config.suspendOnClose = false;\n        }\n\n        config.protocol = config.protocol || {};\n        config.protocol.delta = typeof config.protocol.delta !== 'undefined' ? config.protocol.delta : true; // eslint-disable-next-line no-restricted-globals\n\n        config.Promise = config.Promise || Promise;\n        config.mixins = config.mixins || [];\n        config.definition = config.definition || new Schema(config);\n      }\n      /**\n      * Function used to create a QIX session.\n      * @entry\n      * @param {Configuration} config The configuration object for the QIX session.\n      * @returns {Session} Returns a new QIX session.\n      * @example <caption>Example minimal session creation</caption>\n      * const enigma = require('enigma.js');\n      * const schema = require('enigma.js/schemas/12.20.0.json');\n      * const WebSocket = require('ws');\n      * const config = {\n      *   schema,\n      *   url: 'ws://localhost:9076/app/engineData',\n      *   createSocket: url => new WebSocket(url),\n      * };\n      * const session = enigma.create(config);\n      */\n\n    }, {\n      key: \"create\",\n      value: function create(config) {\n        Enigma.configureDefaults(config);\n        config.mixins.forEach(function (mixin) {\n          config.definition.registerMixin(mixin);\n        });\n        return Enigma.getSession(config);\n      }\n    }]);\n\n    return Enigma;\n  }();\n\n  return Enigma;\n});","map":{"version":3,"sources":["node_modules/node-event-emitter/index.js","src/event-emitter.js","src/error.js","src/error-codes.js","src/session.js","src/key-value-cache.js","src/schema.js","src/rpc-resolver.js","src/rpc.js","src/suspend-resume.js","src/interceptors/delta-request-interceptor.js","src/interceptors/api-response-interceptor.js","node_modules/extend/index.js","src/json-patch.js","src/interceptors/delta-response-interceptor.js","src/interceptors/error-response-interceptor.js","src/interceptors/out-param-response-interceptor.js","src/interceptors/result-response-interceptor.js","src/intercept.js","src/api-cache.js","src/enigma.js"],"names":["mixin","Object","EventEmitter","obj","EnigmaError","Error","errorCodes","NOT_CONNECTED","OBJECT_NOT_FOUND","EXPECTED_ARRAY_OF_PATCHES","PATCH_HAS_NO_PARENT","ENTRY_ALREADY_DEFINED","NO_CONFIG_SUPPLIED","PROMISE_REQUIRED","SCHEMA_STRUCT_TYPE_NOT_FOUND","SCHEMA_MIXIN_CANT_OVERRIDE_FUNCTION","SCHEMA_MIXIN_EXTEND_NOT_ALLOWED","SESSION_SUSPENDED","SESSION_NOT_ATTACHED","RPC_CLOSE_NORMAL","RPC_CLOSE_MANUAL_SUSPEND","cacheId","Session","session","evt","code","reason","initiator","response","api","entry","handle","id","type","genericType","args","factory","createEnigmaError","request","promise","data","augmentedRequest","then","params","chain","KeyValueCache","key","value","hasOwnProperty","symbol","_typeof","Array","valid","defaults","base","Schema","config","types","extend","override","init","cached","entryList","instance","Events","enumerable","writable","customKey","mixinList","out","schema","outKey","fnName","toCamelCase","method","baseFn","result","item","namedParamFacade","RPCResolver","RPC","force","JSON","event","resolver","error","ON_ATTACHED_TIMEOUT_MS","SuspendResume","dir","sessionState","global","changed","doc","openDocParams","closed","tasks","apis","notificationReceived","notificationPromise","notificationResolve","waitForNotification","timer","setTimeout","onNotification","clearTimeout","SUCCESS_KEY","delta","qGenericType","isArray","originalExtend","JSONPatch","v","val","isFunction","seperator","parts","str","i","numPart","newPart","isNaN","isUndef","isSpecialProperty","isIdentical","isObject","compare","a","b","l","patches","oldA","original","tmpIdx","ii","ll","newA","op","path","findIndex","from","basePath","generateValue","newData","oldVal","tmpPath","patchArray","parent","getParent","patch","target","chunkSize","chunk","emptyObject","oldParent","sessions","bindSession","cache","getHandleCache","patchValue","deltaResponseInterceptor","RETURN_KEY","Intercept","onFulfilled","deltaRequest","errorResponse","deltaResponse","resultResponse","outParamResponse","apiResponse","intercept","interceptor","interception","ApiCache","Enigma","createSocket","Promise","requestInterceptors","responseInterceptors","url","rpc","suspendResume"],"mappings":"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A,GAAgC,KAAA,GAAA,CAASC,MAAM,CAA/C,QAAyCA,EAAT,CAAhC,GAAd,SAAA;AACA,eAAOD,KAAK,IAAIA,KAAK,CAArB,GAAA;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;aACE,SAAA,OAAA,GAAU;AACR,eAAO,IAAA,CAAA,eAAA,CAAA,QAAA,CAAA,SAAA,CAAA,EAAA,QAAA,EAAA,IAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAA,GAAA,CAAmB,UAAA,KAAA,EAAA;AAAA,iBAAY;AACpCC,YAAAA,MAAM,EAAED,KAAK,CADuB,GAAA;AAEpCD,YAAAA,GAAG,EAAEC,KAAK,CAALA,KAAAA,CAAYD;AAFmB,WAAZ;AAA1B,SAAO,CAAP;AAID;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;aACE,SAAA,aAAA,CAAA,IAAA,EAAoB;AAClB,eAAO,KAAA,OAAA,GAAA,MAAA,CAAsB,UAAA,KAAA,EAAA;AAAA,iBAAWC,KAAK,CAALA,GAAAA,CAAAA,IAAAA,KAAX,IAAA;AAA7B,SAAO,CAAP;AACD;;;;GAlDG8I,CAAiB/H,aAAjB+H,C;;;;;;;;;;;;;;;;;;;;;;;ACGN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","sourcesContent":["/**\n * Utility functions\n */\n\nvar util = {};\n\nutil.isObject = function isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nutil.isNumber = function isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nutil.isUndefined = function isUndefined(arg) {\n  return arg === void 0;\n}\n\nutil.isFunction = function isFunction(arg){\n  return typeof arg === 'function';\n}\n\n\n/**\n * EventEmitter class\n */\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.init = function() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!util.isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error' && !this._events.error) {\n    er = arguments[1];\n    if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      throw Error('Uncaught, unspecified \"error\" event.');\n    }\n    return false;\n  }\n\n  handler = this._events[type];\n\n  if (util.isUndefined(handler))\n    return false;\n\n  if (util.isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (util.isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              util.isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (util.isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (util.isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!util.isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n\n      if (util.isFunction(console.error)) {\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n      }\n      if (util.isFunction(console.trace))\n        console.trace();\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (util.isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (util.isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (util.isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (Array.isArray(listeners)) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (util.isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (util.isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n","import EventEmitter from 'node-event-emitter';\n\n/**\n* @module EventEmitter\n* @private\n*/\nexport default {\n\n  /**\n  * Function used to add event handling to objects passed in.\n  * @param {Object} obj Object instance that will get event handling.\n  */\n  mixin: (obj) => {\n    Object.keys(EventEmitter.prototype).forEach((key) => {\n      obj[key] = EventEmitter.prototype[key];\n    });\n    EventEmitter.init(obj);\n  },\n};\n","/**\n * Error containing a custom error code.\n * @extends Error\n * @property {number} code The error code as defined by `errorCodes`.\n * @property {boolean} enigmaError=true\n */\nclass EnigmaError extends Error {\n  constructor(name, code) {\n    super(name);\n    this.code = code;\n    this.enigmaError = true;\n  }\n}\n\n/**\n * Create an enigmaError\n * @private\n * @param {Number} code A proper error code from `errorCodes`\n * @param {String} name A message/name of the enigmaError.\n * @returns {EnigmaError}\n */\nexport default function createEnigmaError(code, name) {\n  return new EnigmaError(name, code);\n}\n","/**\n * This is a list of error codes that can be thrown from enigma.js API calls.\n * @entry\n * @see EnigmaError\n * @enum\n * @example <caption>Handling an enigma.js error</caption>\n * const { NOT_CONNECTED } = require('enigma.js/error-codes');\n * try {\n *   const layout = await model.getLayout();\n * } catch (err) {\n *   if (err.code === NOT_CONNECTED) {\n *     console.log('Tried to communicate on a session that is closed');\n *   }\n * }\n */\nconst errorCodes = {\n  /**\n   * You're trying to send data on a socket that's not connected.\n   * @type {number}\n   */\n  NOT_CONNECTED: -1,\n  /**\n   * The object you're trying to fetch does not exist.\n   * @type {number}\n   */\n  OBJECT_NOT_FOUND: -2,\n  /**\n   * Unexpected RPC response, expected array of patches.\n   * @type {number}\n   */\n  EXPECTED_ARRAY_OF_PATCHES: -3,\n  /**\n   * Not an object that can be patched.\n   * @type {number}\n   */\n  PATCH_HAS_NO_PARENT: -4,\n  /**\n   * This entry is already defined with another key.\n   * @type {number}\n   */\n  ENTRY_ALREADY_DEFINED: -5,\n  /**\n   * You need to supply a configuration.\n   * @type {number}\n   */\n  NO_CONFIG_SUPPLIED: -6,\n  /**\n   * There's no promise object available (polyfill required?).\n   * @type {number}\n   */\n  PROMISE_REQUIRED: -7,\n  /**\n   * The schema struct type you requested does not exist.\n   * @type {number}\n   */\n  SCHEMA_STRUCT_TYPE_NOT_FOUND: -8,\n  /**\n   * Can't override this function.\n   * @type {number}\n   */\n  SCHEMA_MIXIN_CANT_OVERRIDE_FUNCTION: -9,\n  /**\n   * Extend is not allowed for this mixin.\n   * @type {number}\n   */\n  SCHEMA_MIXIN_EXTEND_NOT_ALLOWED: -10,\n  /**\n   * Session suspended - no interaction allowed.\n   * @type {number}\n   */\n  SESSION_SUSPENDED: -11,\n  /**\n   * onlyIfAttached supplied, but you got SESSION_CREATED.\n   * @type {number}\n   */\n  SESSION_NOT_ATTACHED: -12,\n};\n\nexport default errorCodes;\n","import EventEmitter from './event-emitter';\n\nimport createEnigmaError from './error';\nimport errorCodes from './error-codes';\n\nconst RPC_CLOSE_NORMAL = 1000;\nconst RPC_CLOSE_MANUAL_SUSPEND = 4000;\n\nlet cacheId = 0;\n\n/**\n * The QIX Engine session object.\n */\nclass Session {\n  /**\n   * Handles all JSON-RPC notification events, 'notification:* or handles a specific JSON-RPC\n   * notification event, 'notification:OnConnected'. These events depend on the product from which\n   * you use QIX Engine.\n   * @event Session#notification\n   * @type {Object}\n   * @example <caption>Bind the notification events</caption>\n   * // bind all notifications to console.log:\n   * session.on('notification:*', console.log);\n   * // bind a specific notification to console.log:\n   * session.on('notification:OnConnected', console.log);\n   */\n\n  /**\n   * Handles websocket messages. Generally used for debugging purposes. `traffic:*` will handle all\n   * websocket messages, `traffic:sent` will handle outgoing messages, and `traffic:received` will\n   * handle incoming messages.\n   * @event Session#traffic\n   * @type {Object}\n   * @example <caption>Bind the traffic events</caption>\n   * // bind both in- and outbound traffic to console.log:\n   * session.on('traffic:*', console.log);\n   * // bind outbound traffic to console.log:\n   * session.on('traffic:sent', console.log);\n   * // bind inbound traffic to console.log:\n   * session.on('traffic:received', console.log);\n   */\n\n  constructor(options) {\n    const session = this;\n    Object.assign(session, options);\n    this.Promise = this.config.Promise;\n    this.definition = this.config.definition;\n    EventEmitter.mixin(session);\n    cacheId += 1;\n    session.id = cacheId;\n    session.rpc.on('socket-error', session.onRpcError.bind(session));\n    session.rpc.on('closed', session.onRpcClosed.bind(session));\n    session.rpc.on('message', session.onRpcMessage.bind(session));\n    session.rpc.on('notification', session.onRpcNotification.bind(session));\n    session.rpc.on('traffic', session.onRpcTraffic.bind(session));\n    session.on('closed', () => session.onSessionClosed());\n  }\n\n  /**\n  * Event handler for re-triggering error events from RPC.\n  * @private\n  * @emits socket-error\n  * @param {Error} err Webocket error event.\n  */\n  onRpcError(err) {\n    if (this.suspendResume.isSuspended) {\n      return;\n    }\n    this.emit('socket-error', err);\n  }\n\n  /**\n  * Event handler for the RPC close event.\n  * @private\n  * @emits Session#suspended\n  * @emits Session#closed\n  * @param {Event} evt WebSocket close event.\n  */\n  onRpcClosed(evt) {\n    /**\n     * Handles suspended state. This event is triggered in two cases (listed below). It is useful\n     * in scenarios where, for example, you want to block interaction with your application until\n     * you resume again. Or, if config.suspendOnClose is true and there was a network disconnect\n     * (socket closed) or if you ran session.suspend().\n     * @event Session#suspended\n     * @type {Object}\n     * @param {Object} evt Event object.\n     * @param {String} evt.initiator String indication what triggered the suspended state. Possible\n     * values network, manual.\n     * @example <caption>Handling session suspended</caption>\n     * session.on('suspended', () => {\n     *   console.log('Session was suspended, retrying...');\n     *   session.resume();\n     * });\n     */\n    if (this.suspendResume.isSuspended) {\n      return;\n    }\n    if (evt.code === RPC_CLOSE_NORMAL || evt.code === RPC_CLOSE_MANUAL_SUSPEND) {\n      return;\n    }\n    if (this.config.suspendOnClose) {\n      const { code, reason } = evt;\n      this.suspendResume.suspend().then(() => this.emit('suspended', {\n        initiator: 'network',\n        code,\n        reason,\n      }));\n    } else {\n      this.emit('closed', evt);\n    }\n  }\n\n  /**\n  * Event handler for the RPC message event.\n  * @private\n  * @param {Object} response JSONRPC response.\n  */\n  onRpcMessage(response) {\n    if (this.suspendResume.isSuspended) {\n      return;\n    }\n    if (response.change) {\n      response.change.forEach((handle) => this.emitHandleChanged(handle));\n    }\n    if (response.close) {\n      response.close.forEach((handle) => this.emitHandleClosed(handle));\n    }\n  }\n\n  /**\n  * Event handler for the RPC notification event.\n  * @private\n  * @emits Session#notification\n  * @param {Object} response The JSONRPC notification.\n  */\n  onRpcNotification(response) {\n    this.emit('notification:*', response.method, response.params);\n    this.emit(`notification:${response.method}`, response.params);\n  }\n\n  /**\n  * Event handler for the RPC traffic event.\n  * @private\n  * @emits Session#traffic\n  * @param {String} dir The traffic direction, sent or received.\n  * @param {Object} data JSONRPC request/response/WebSocket message.\n  * @param {Number} handle The associated handle.\n  */\n  onRpcTraffic(dir, data, handle) {\n    this.emit('traffic:*', dir, data);\n    this.emit(`traffic:${dir}`, data);\n    const api = this.apis.getApi(handle);\n    if (api) {\n      api.emit('traffic:*', dir, data);\n      api.emit(`traffic:${dir}`, data);\n    }\n  }\n\n  /**\n  * Event handler for cleaning up API instances when a session has been closed.\n  * @private\n  * @emits API#closed\n  */\n  onSessionClosed() {\n    this.apis.getApis().forEach((entry) => {\n      entry.api.emit('closed');\n      entry.api.removeAllListeners();\n    });\n    this.apis.clear();\n  }\n\n  /**\n   * Function used to get an API for a backend object.\n   * @private\n   * @param {Object} args Arguments used to create object API.\n   * @param {Number} args.handle Handle of the backend object.\n   * @param {String} args.id ID of the backend object.\n   * @param {String} args.type QIX type of the backend object. Can for example\n   *                           be \"Doc\" or \"GenericVariable\".\n   * @param {String} args.genericType Custom type of the backend object, if defined in qInfo.\n   * @returns {Object} Returns the generated and possibly augmented API.\n   */\n  getObjectApi(args) {\n    const {\n      handle, id, type, genericType,\n    } = args;\n    let api = this.apis.getApi(handle);\n    if (api) {\n      return api;\n    }\n    const factory = this.definition.generate(type);\n    api = factory(this, handle, id, genericType);\n    this.apis.add(handle, api);\n    return api;\n  }\n\n  /**\n  * Establishes the websocket against the configured URL and returns the Global instance.\n  * @emits Session#opened\n  * @returns {Promise<Object>} Eventually resolved if the connection was successful.\n  * @example <caption>Opening a sesssion</caption>\n  * session.open().then(() => {\n  *   console.log('Session was opened');\n  * });\n  */\n  open() {\n    /**\n     * Handles opened state. This event is triggered whenever the websocket is connected and\n     * ready for communication.\n     * @event Session#opened\n     * @type {Object}\n     * @example <caption>Bind the session opened event</caption>\n     * session.on('opened', () => {\n     *   console.log('Session was opened');\n     * });\n     */\n    if (!this.globalPromise) {\n      const args = {\n        handle: -1,\n        id: 'Global',\n        type: 'Global',\n        genericType: 'Global',\n      };\n      this.globalPromise = this.rpc.open()\n        .then(() => this.getObjectApi(args))\n        .then((global) => {\n          this.emit('opened');\n          return global;\n        });\n    }\n    return this.globalPromise;\n  }\n\n  /**\n  * Function used to send data on the RPC socket.\n  * @param {Object} request The request to be sent. (data and some meta info)\n  * @returns {Object} Returns a promise instance.\n  */\n  send(request) {\n    if (this.suspendResume.isSuspended) {\n      return this.Promise.reject(createEnigmaError(errorCodes.SESSION_SUSPENDED, 'Session suspended'));\n    }\n    request.id = this.rpc.createRequestId();\n    const promise = this.intercept.executeRequests(this, this.Promise.resolve(request))\n      .then((augmentedRequest) => {\n        const data = { ...this.config.protocol, ...augmentedRequest };\n        // the outKey value is used by multiple-out interceptor, at some point\n        // we need to refactor that implementation and figure out how to transport\n        // this value without hijacking the JSONRPC request object:\n        delete data.outKey;\n        const response = this.rpc.send(data);\n        augmentedRequest.retry = () => this.send(request);\n        return this.intercept.executeResponses(this, response, augmentedRequest);\n      });\n    Session.addToPromiseChain(promise, 'requestId', request.id);\n    return promise;\n  }\n\n  /**\n  * Suspends the enigma.js session by closing the websocket and rejecting all method calls\n  * until it is has resumed again.\n  * @emits Session#suspended\n  * @param {Number} [code=4000] - The reason code for suspending the connection.\n  * @param {String} [reason=\"\"] - The human readable string describing\n  * why the connection is suspended.\n  * @returns {Promise<Object>} Eventually resolved when the websocket has been closed.\n  * @example <caption>Suspending a session</caption>\n  * session.suspend().then(() => {\n  *   console.log('Session was suspended');\n  * });\n  */\n  suspend(code = 4000, reason = '') {\n    return this.suspendResume.suspend(code, reason)\n      .then(() => this.emit('suspended', { initiator: 'manual', code, reason }));\n  }\n\n  /**\n  * Resumes a previously suspended enigma.js session by recreating the websocket and,\n  * if possible, reopen the document as well as refreshing the internal cashes. If successful,\n  * changed events will be triggered on all generated APIs, and on the ones it was unable to\n  * restore, the closed event will be triggered.\n  * @emits Session#resumed\n  * @param {Boolean} onlyIfAttached If true, resume only if the session was reattached properly.\n  * @returns {Promise<Object>} Eventually resolved when the websocket (and potentially the\n  * previously opened document, and generated APIs) has been restored; it is rejected when it fails\n  * any of those steps, or when onlyIfAttached is true and a new session was created.\n  * @example <caption>Resuming a session</caption>\n  * session.resume(true).then(() => {\n  *   console.log('Session was resumed by re-attaching');\n  * });\n  */\n  resume(onlyIfAttached) {\n    /**\n     * Handles resumed state. This event is triggered when the session was properly resumed. It is\n     * useful in scenarios where, for example, you can close blocking modal dialogs and allow the\n     * user to interact with your application again.\n     * @event Session#resumed\n     * @type {Object}\n     * @example <caption>Handling session resumed</caption>\n     * session.on('resumed', () => {\n     *   console.log('Session was resumed, we can close that \"reconnecting\" dialog now');\n     * });\n     */\n    return this.suspendResume.resume(onlyIfAttached).then((value) => {\n      this.emit('resumed');\n      return value;\n    });\n  }\n\n  /**\n  * Closes the websocket and cleans up internal caches. Also triggers the closed event\n  * on all generated APIs. Note that you have to manually invoke this when you want to\n  * close a session and config.suspendOnClose is true.\n  * @emits Session#closed\n  * @param {Number} [code=1000] - The reason code for closing the connection.\n  * @param {String} [reason=\"\"] - The human readable string describing why the connection is closed.\n  * @returns {Promise<Object>} Eventually resolved when the websocket has been closed.\n  * @example <caption>Closing a session</caption>\n  * session.close().then(() => {\n  *   console.log('Session was closed');\n  * });\n  */\n  close(code = 1000, reason = '') {\n    /**\n     * Handles closed state. This event is triggered when the underlying websocket is closed and\n     * config.suspendOnClose is false.\n     * @event Session#closed\n     * @type {Object}\n     * @example <caption>Handling session closed</caption>\n     * session.on('closed', () => {\n     *   console.log('Session was closed, clean up!');\n     * });\n     */\n    this.globalPromise = undefined;\n    return this.rpc.close(code, reason).then((evt) => this.emit('closed', evt));\n  }\n\n  /**\n  * Given a handle, this function will emit the 'changed' event on the\n  * corresponding API instance.\n  * @private\n  * @param {Number} handle The handle of the API instance.\n  * @emits API#changed\n  */\n  emitHandleChanged(handle) {\n    const api = this.apis.getApi(handle);\n    if (api) {\n      api.emit('changed');\n    }\n  }\n\n  /**\n  * Given a handle, this function will emit the 'closed' event on the\n  * corresponding API instance.\n  * @private\n  * @param {Number} handle The handle of the API instance.\n  * @emits API#closed\n  */\n  emitHandleClosed(handle) {\n    const api = this.apis.getApi(handle);\n    if (api) {\n      api.emit('closed');\n      api.removeAllListeners();\n    }\n  }\n\n  /**\n  * Function used to add info on the promise chain.\n  * @private\n  * @param {Promise<Object>} promise The promise to add info on.\n  * @param {String} name The property to add info on.\n  * @param {Any} value The info to add.\n  */\n  static addToPromiseChain(promise, name, value) {\n    promise[name] = value;\n    const { then } = promise;\n    promise.then = function patchedThen(...params) {\n      const chain = then.apply(this, params);\n      Session.addToPromiseChain(chain, name, value);\n      return chain;\n    };\n  }\n}\n\nexport default Session;\n","import createEnigmaError from './error';\nimport errorCodes from './error-codes';\n\n/**\n* Key-value cache\n* @private\n*/\nclass KeyValueCache {\n  constructor() {\n    this.entries = {};\n  }\n\n  /**\n  * Adds an entry.\n  * @private\n  * @function KeyValueCache#add\n  * @param {String} key The key representing an entry.\n  * @param {*} entry The entry to be added.\n  */\n  add(key, entry) {\n    key += '';\n    if (typeof this.entries[key] !== 'undefined') {\n      throw createEnigmaError(errorCodes.ENTRY_ALREADY_DEFINED, `Entry already defined with key ${key}`);\n    }\n    this.entries[key] = entry;\n  }\n\n  /**\n  * Sets an entry.\n  * @private\n  * @function KeyValueCache#set\n  * @param {String} key The key representing an entry.\n  * @param {*} entry The entry.\n  */\n  set(key, entry) {\n    key += '';\n    this.entries[key] = entry;\n  }\n\n  /**\n  * Removes an entry.\n  * @private\n  * @function KeyValueCache#remove\n  * @param {String} key The key representing an entry.\n  */\n  remove(key) {\n    delete this.entries[key];\n  }\n\n  /**\n  * Gets an entry.\n  * @private\n  * @function KeyValueCache#get\n  * @param {String} key The key representing an entry.\n  * @returns {*} The entry for the key.\n  */\n  get(key) {\n    return this.entries[key];\n  }\n\n  /**\n  * Gets a list of all entries.\n  * @private\n  * @function KeyValueCache#getAll\n  * @returns {Array} The list of entries including its `key` and `value` properties.\n  */\n  getAll() {\n    return Object.keys(this.entries).map((key) => ({\n      key,\n      value: this.entries[key],\n    }));\n  }\n\n  /**\n  * Gets a key for an entry.\n  * @private\n  * @function KeyValueCache#getKey\n  * @param {*} entry The entry to locate the key for.\n  * @returns {String} The key representing an entry.\n  */\n  getKey(entry) {\n    return Object.keys(this.entries).filter((key) => this.entries[key] === entry)[0];\n  }\n\n  /**\n  * Clears the cache of all entries.\n  * @private\n  * @function KeyValueCache#clear\n  */\n  clear() {\n    this.entries = {};\n  }\n}\n\nexport default KeyValueCache;\n","import KeyValueCache from './key-value-cache';\nimport Events from './event-emitter';\n\nimport createEnigmaError from './error';\nimport errorCodes from './error-codes';\n\nconst { hasOwnProperty } = Object.prototype;\n\n/**\n* Returns the camelCase counterpart of a symbol.\n* @private\n* @param {String} symbol The symbol.\n* @return the camelCase counterpart.\n*/\nfunction toCamelCase(symbol) {\n  return symbol.substring(0, 1).toLowerCase() + symbol.substring(1);\n}\n\n/**\n * A facade function that allows parameters to be passed either by name\n * (through an object), or by position (through an array).\n * @private\n * @param {Function} base The function that is being overriden. Will be\n *                        called with parameters in array-form.\n * @param {Object} defaults Parameter list and it's default values.\n * @param {*} params The parameters.\n */\nfunction namedParamFacade(base, defaults, ...params) {\n  if (params.length === 1 && typeof params[0] === 'object' && !Array.isArray(params[0])) {\n    const valid = Object.keys(params[0]).every((key) => hasOwnProperty.call(defaults, key));\n    if (valid) {\n      params = Object.keys(defaults).map((key) => params[0][key] || defaults[key]);\n    }\n  }\n  return base.apply(this, params);\n}\n\n/**\n* Qix schema definition.\n* @private\n*/\nclass Schema {\n  /**\n  * Create a new schema instance.\n  * @private\n  * @param {Configuration} config The configuration for QIX.\n  */\n  constructor(config) {\n    this.config = config;\n    this.Promise = config.Promise;\n    this.schema = config.schema;\n    this.mixins = new KeyValueCache();\n    this.types = new KeyValueCache();\n  }\n\n  registerMixin({\n    types, type, extend, override, init,\n  }) {\n    if (!Array.isArray(types)) {\n      types = [types];\n    }\n    // to support a single type\n    if (type) {\n      types.push(type);\n    }\n    const cached = { extend, override, init };\n    types.forEach((typeKey) => {\n      const entryList = this.mixins.get(typeKey);\n      if (entryList) {\n        entryList.push(cached);\n      } else {\n        this.mixins.add(typeKey, [cached]);\n      }\n    });\n  }\n\n  /**\n  * Function used to generate a type definition.\n  * @private\n  * @param {String} type The type.\n  * @returns {{create: Function, def: Object}} Returns an object with a definition\n  *          of the type and a create factory.\n  */\n  generate(type) {\n    const entry = this.types.get(type);\n    if (entry) {\n      return entry;\n    }\n    if (!this.schema.structs[type]) {\n      throw createEnigmaError(errorCodes.SCHEMA_STRUCT_TYPE_NOT_FOUND, `${type} not found`);\n    }\n    const factory = this.generateApi(type, this.schema.structs[type]);\n    this.types.add(type, factory);\n    return factory;\n  }\n\n  /**\n  * Function used to generate an API definition for a given type.\n  * @private\n  * @param {String} type The type to generate.\n  * @param {Object} schema The schema describing the type.\n  * @returns {{create: (function(session:Object, handle:Number, id:String,\n  *          customKey:String)), def: Object}} Returns the API definition.\n  */\n  generateApi(type, schema) {\n    const api = Object.create({});\n\n    this.generateDefaultApi(api, schema); // Generate default\n    this.mixinType(type, api); // Mixin default type\n    this.mixinNamedParamFacade(api, schema); // Mixin named parameter support\n\n    return function create(session, handle, id, customKey) {\n      const instance = Object.create(api);\n\n      Events.mixin(instance); // Always mixin event-emitter per instance\n\n      Object.defineProperties(instance, {\n        session: {\n          enumerable: true,\n          value: session,\n        },\n        handle: {\n          enumerable: true,\n          value: handle,\n          writable: true,\n        },\n        id: {\n          enumerable: true,\n          value: id,\n        },\n        type: {\n          enumerable: true,\n          value: type,\n        },\n        genericType: {\n          enumerable: true,\n          value: customKey,\n        },\n      });\n\n      let mixinList = this.mixins.get(type) || [];\n      if (customKey !== type) {\n        this.mixinType(customKey, instance); // Mixin custom types\n        mixinList = mixinList.concat(this.mixins.get(customKey) || []);\n      }\n      mixinList.forEach((mixin) => {\n        if (typeof mixin.init === 'function') {\n          mixin.init({ config: this.config, api: instance });\n        }\n      });\n\n      return instance;\n    }.bind(this);\n  }\n\n  /**\n  * Function used to generate the methods with the right handlers to the object\n  * API that is being generated.\n  * @private\n  * @param {Object} api The object API that is currently being generated.\n  * @param {Object} schema The API definition.\n  */\n  generateDefaultApi(api, schema) {\n    Object.keys(schema).forEach((method) => {\n      const out = schema[method].Out;\n      const outKey = out.length === 1 ? out[0].Name : -1;\n      const fnName = toCamelCase(method);\n\n      api[fnName] = function generatedMethod(...params) {\n        return this.session.send({\n          handle: this.handle,\n          method,\n          params,\n          outKey,\n        });\n      };\n    });\n  }\n\n  /**\n  * Function used to add mixin methods to a specified API.\n  * @private\n  * @param {String} type Used to specify which mixin should be woven in.\n  * @param {Object} api The object that will be woven.\n  */\n  mixinType(type, api) {\n    const mixinList = this.mixins.get(type);\n    if (mixinList) {\n      mixinList.forEach(({ extend = {}, override = {} }) => {\n        Object.keys(override).forEach((key) => {\n          if (typeof api[key] === 'function' && typeof override[key] === 'function') {\n            const baseFn = api[key];\n            api[key] = function wrappedFn(...args) {\n              return override[key].apply(this, [baseFn.bind(this), ...args]);\n            };\n          } else {\n            throw createEnigmaError(errorCodes.SCHEMA_MIXIN_CANT_OVERRIDE_FUNCTION, `No function to override. Type: ${type} function: ${key}`);\n          }\n        });\n        Object.keys(extend).forEach((key) => {\n          // handle overrides\n          if (typeof api[key] === 'function' && typeof extend[key] === 'function') {\n            throw createEnigmaError(errorCodes.SCHEMA_MIXIN_EXTEND_NOT_ALLOWED, `Extend is not allowed for this mixin. Type: ${type} function: ${key}`);\n          } else {\n            api[key] = extend[key];\n          }\n        });\n      });\n    }\n  }\n\n  /**\n  * Function used to mixin the named parameter facade.\n  * @private\n  * @param {Object} api The object API that is currently being generated.\n  * @param {Object} schema The API definition.\n  */\n  mixinNamedParamFacade(api, schema) {\n    Object.keys(schema).forEach((key) => {\n      const fnName = toCamelCase(key);\n      const base = api[fnName];\n      const defaults = schema[key].In.reduce((result, item) => {\n        result[item.Name] = item.DefaultValue;\n        return result;\n      }, {});\n\n      api[fnName] = function namedParamWrapper(...params) {\n        return namedParamFacade.apply(this, [base, defaults, ...params]);\n      };\n    });\n  }\n}\n\nexport default Schema;\n","import Events from './event-emitter';\n\n/**\n * Helper class for handling RPC calls\n * @private\n */\nclass RPCResolver {\n  constructor(id, handle, resolve, reject) {\n    Events.mixin(this);\n    this.id = id;\n    this.handle = handle;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n\n  resolveWith(data) {\n    this.resolve(data);\n    this.emit('resolved', this.id);\n  }\n\n  rejectWith(err) {\n    this.reject(err);\n    this.emit('rejected', this.id);\n  }\n}\n\nexport default RPCResolver;\n","import Events from './event-emitter';\nimport RPCResolver from './rpc-resolver';\n\nimport createEnigmaError from './error';\nimport errorCodes from './error-codes';\n\n/**\n* This class handles remote procedure calls on a web socket.\n* @private\n*/\nclass RPC {\n  /**\n  * Create a new RPC instance.\n  * @private\n  * @param {Object} options The configuration options for this class.\n  * @param {Function} options.Promise The promise constructor to use.\n  * @param {String} options.url The complete websocket URL used to connect.\n  * @param {Function} options.createSocket The function callback to create a WebSocket.\n  */\n  constructor(options) {\n    Object.assign(this, options);\n    Events.mixin(this);\n    this.resolvers = {};\n    this.requestId = 0;\n    this.openedPromise = undefined;\n  }\n\n  /**\n  * Opens a connection to the configured endpoint.\n  * @private\n  * @param {Boolean} force - ignores all previous and outstanding open calls if set to true.\n  * @returns {Object} A promise instance.\n  */\n  open(force = false) {\n    if (!force && this.openedPromise) {\n      return this.openedPromise;\n    }\n\n    try {\n      this.socket = this.createSocket(this.url);\n    } catch (err) {\n      return this.Promise.reject(err);\n    }\n\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onerror = this.onError.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n    this.openedPromise = new this.Promise((resolve, reject) => this.registerResolver('opened', null, resolve, reject));\n    this.closedPromise = new this.Promise((resolve, reject) => this.registerResolver('closed', null, resolve, reject));\n    return this.openedPromise;\n  }\n\n  /**\n  * Resolves the open promise when a connection is successfully established.\n  * @private\n  */\n  onOpen() {\n    this.resolvers.opened.resolveWith(() => this.closedPromise);\n  }\n\n  /**\n  * Resolves the close promise when a connection is closed.\n  * @private\n  * @param {Object} event - The event describing close.\n  */\n  onClose(event) {\n    this.emit('closed', event);\n    if (this.resolvers && this.resolvers.closed) {\n      this.resolvers.closed.resolveWith(event);\n    }\n    this.rejectAllOutstandingResolvers(createEnigmaError(errorCodes.NOT_CONNECTED, 'Socket closed'));\n  }\n\n  /**\n  * Closes a connection.\n  * @private\n  * @param {Number} [code=1000] - The reason code for closing the connection.\n  * @param {String} [reason=\"\"] - The human readable string describing why the connection is closed.\n  * @returns {Object} Returns a promise instance.\n  */\n  close(code = 1000, reason = '') {\n    if (this.socket) {\n      this.socket.close(code, reason);\n      this.socket = null;\n    }\n    return this.closedPromise;\n  }\n\n  /**\n  * Emits an error event and rejects the open promise if an error is raised on the connection.\n  * @private\n  * @param {Object} event - The event describing the error.\n  */\n  onError(event) {\n    if (this.resolvers.opened) {\n      this.resolvers.opened.rejectWith(event);\n    } else {\n      // only emit errors after the initial open promise has been resolved,\n      // this makes it possible to catch early websocket errors as well\n      // as run-time ones:\n      this.emit('socket-error', event);\n    }\n    this.rejectAllOutstandingResolvers(createEnigmaError(errorCodes.NOT_CONNECTED, 'Socket error'));\n  }\n\n  /**\n  * Parses the onMessage event on the connection and resolve the promise for the request.\n  * @private\n  * @param {Object} event - The event describing the message.\n  */\n  onMessage(event) {\n    const data = JSON.parse(event.data);\n    const resolver = this.resolvers[data.id] || {};\n    this.emit('traffic', 'received', data, resolver.handle);\n    if (typeof data.id !== 'undefined') {\n      this.emit('message', data);\n      this.resolvers[data.id].resolveWith(data);\n    } else {\n      this.emit(data.params ? 'notification' : 'message', data);\n    }\n  }\n\n  /**\n  * Rejects all outstanding resolvers.\n  * @private\n  * @param {Object} reason - The reject reason.\n  */\n  rejectAllOutstandingResolvers(reason) {\n    Object.keys(this.resolvers).forEach((id) => {\n      if (id === 'opened' || id === 'closed') {\n        return; // \"opened\" and \"closed\" should not be handled here\n      }\n      const resolver = this.resolvers[id];\n      resolver.rejectWith(reason);\n    });\n  }\n\n  /**\n  * Unregisters a resolver.\n  * @private\n  * @param {Number|String} id - The ID to unregister the resolver with.\n  */\n  unregisterResolver(id) {\n    const resolver = this.resolvers[id];\n    resolver.removeAllListeners();\n    delete this.resolvers[id];\n  }\n\n  /**\n  * Registers a resolver.\n  * @private\n  * @param {Number|String} id - The ID to register the resolver with.\n  * @param {Number} handle - The associated handle.\n  * @returns {Function} The promise executor function.\n  */\n  registerResolver(id, handle, resolve, reject) {\n    const resolver = new RPCResolver(id, handle, resolve, reject);\n    this.resolvers[id] = resolver;\n    resolver.on('resolved', (resolvedId) => this.unregisterResolver(resolvedId));\n    resolver.on('rejected', (rejectedId) => this.unregisterResolver(rejectedId));\n  }\n\n  /**\n  * Sends data on the socket.\n  * @private\n  * @param {Object} data - The data to send.\n  * @returns {Object} A promise instance.\n  */\n  send(data) {\n    if (!this.socket || this.socket.readyState !== this.socket.OPEN) {\n      const error = createEnigmaError(errorCodes.NOT_CONNECTED, 'Not connected');\n      return this.Promise.reject(error);\n    }\n    if (!data.id) {\n      data.id = this.createRequestId();\n    }\n    data.jsonrpc = '2.0';\n    return new this.Promise((resolve, reject) => {\n      this.socket.send(JSON.stringify(data));\n      this.emit('traffic', 'sent', data, data.handle);\n      return this.registerResolver(data.id, data.handle, resolve, reject);\n    });\n  }\n\n  createRequestId() {\n    this.requestId += 1;\n    return this.requestId;\n  }\n}\n\nexport default RPC;\n","import createEnigmaError from './error';\nimport errorCodes from './error-codes';\n\nconst ON_ATTACHED_TIMEOUT_MS = 5000;\nconst RPC_CLOSE_MANUAL_SUSPEND = 4000;\n\nclass SuspendResume {\n  /**\n  * Creates a new SuspendResume instance.\n  * @private\n  * @param {Object} options The configuration option for this class.\n  * @param {Promise<Object>} options.Promise The promise constructor to use.\n  * @param {RPC} options.rpc The RPC instance to use when communicating towards Engine.\n  * @param {ApiCache} options.apis The ApiCache instance to use.\n  */\n  constructor(options) {\n    Object.assign(this, options);\n    this.isSuspended = false;\n    this.rpc.on('traffic', (dir, data) => {\n      if (dir === 'sent' && data.method === 'OpenDoc') {\n        this.openDocParams = data.params;\n      }\n    });\n  }\n\n  /**\n  * Function used to restore the rpc connection.\n  * @private\n  * @param {Boolean} onlyIfAttached - if true, the returned promise will resolve\n  *                                   only if the session can be re-attached.\n  * @returns {Object} Returns a promise instance.\n  */\n  restoreRpcConnection(onlyIfAttached) {\n    return this.reopen(ON_ATTACHED_TIMEOUT_MS).then((sessionState) => {\n      if (sessionState === 'SESSION_CREATED' && onlyIfAttached) {\n        return this.Promise.reject(createEnigmaError(errorCodes.SESSION_NOT_ATTACHED, 'Not attached'));\n      }\n      return this.Promise.resolve();\n    });\n  }\n\n  /**\n  * Function used to restore the global API.\n  * @private\n  * @param {Object} changed - A list where the restored APIs will be added.\n  * @returns {Object} Returns a promise instance.\n  */\n  restoreGlobal(changed) {\n    const global = this.apis.getApisByType('Global').pop();\n    changed.push(global.api);\n    return this.Promise.resolve();\n  }\n\n  /**\n  * Function used to restore the doc API.\n  * @private\n  * @param {String} sessionState - The state of the session, attached or created.\n  * @param {Array} closed - A list where the closed of APIs APIs will be added.\n  * @param {Object} changed - A list where the restored APIs will be added.\n  * @returns {Object} Returns a promise instance.\n  */\n  restoreDoc(closed, changed) {\n    const doc = this.apis.getApisByType('Doc').pop();\n\n    if (!doc) {\n      return this.Promise.resolve();\n    }\n\n    return this.rpc.send({\n      method: 'GetActiveDoc',\n      handle: -1,\n      params: [],\n    }).then((response) => {\n      if (response.error && this.openDocParams) {\n        return this.rpc.send({\n          method: 'OpenDoc',\n          handle: -1,\n          params: this.openDocParams,\n        });\n      }\n      return response;\n    }).then((response) => {\n      if (response.error) {\n        closed.push(doc.api);\n        return this.Promise.resolve();\n      }\n      const handle = response.result.qReturn.qHandle;\n      doc.api.handle = handle;\n      changed.push(doc.api);\n      return this.Promise.resolve(doc.api);\n    });\n  }\n\n  /**\n  * Function used to restore the APIs on the doc.\n  * @private\n  * @param {Object} doc - The doc API on which the APIs we want to restore exist.\n  * @param {Array} closed - A list where the closed of APIs APIs will be added.\n  * @param {Object} changed - A list where the restored APIs will be added.\n  * @returns {Object} Returns a promise instance.\n  */\n  restoreDocObjects(doc, closed, changed) {\n    const tasks = [];\n    const apis = this.apis.getApis()\n      .map((entry) => entry.api)\n      .filter((api) => api.type !== 'Global' && api.type !== 'Doc');\n\n    if (!doc) {\n      apis.forEach((api) => closed.push(api));\n      return this.Promise.resolve();\n    }\n\n    apis.forEach((api) => {\n      const method = SuspendResume.buildGetMethodName(api.type);\n\n      if (!method) {\n        closed.push(api);\n      } else {\n        const request = this.rpc.send({\n          method,\n          handle: doc.handle,\n          params: [api.id],\n        }).then((response) => {\n          if (response.error || !response.result.qReturn.qHandle) {\n            closed.push(api);\n          } else {\n            api.handle = response.result.qReturn.qHandle;\n            changed.push(api);\n          }\n        });\n        tasks.push(request);\n      }\n    });\n    return this.Promise.all(tasks);\n  }\n\n  /**\n  * Set the instance as suspended.\n  * @private\n  * @param {Number} [code=4000] - The reason code for suspending the connection.\n  * @param {String} [reason=\"\"] - The human readable string describing\n  * why the connection is suspended.\n  */\n  suspend(code = RPC_CLOSE_MANUAL_SUSPEND, reason = '') {\n    this.isSuspended = true;\n    return this.rpc.close(code, reason);\n  }\n\n  /**\n  * Resumes a previously suspended RPC connection, and refreshes the API cache.\n  *                                APIs unabled to be restored has their 'closed'\n  *                                event triggered, otherwise 'changed'.\n  * @private\n  * @emits API#changed\n  * @emits APIfunction@#closed\n  * @param {Boolean} onlyIfAttached if true, resume only if the session was re-attached.\n  * @returns {Promise<Object>} Eventually resolved if the RPC connection was successfully resumed,\n  *                    otherwise rejected.\n  */\n  resume(onlyIfAttached) {\n    const changed = [];\n    const closed = [];\n\n    return this.restoreRpcConnection(onlyIfAttached)\n      .then(() => this.restoreGlobal(changed))\n      .then(() => this.restoreDoc(closed, changed))\n      .then((doc) => this.restoreDocObjects(doc, closed, changed))\n      .then(() => {\n        this.isSuspended = false;\n        this.apis.clear();\n        closed.forEach((api) => {\n          api.emit('closed');\n          api.removeAllListeners();\n        });\n        changed.forEach((api) => {\n          this.apis.add(api.handle, api);\n          if (api.type !== 'Global') {\n            api.emit('changed');\n          }\n        });\n      })\n      .catch((err) => this.rpc.close().then(() => this.Promise.reject(err)));\n  }\n\n  /**\n  * Reopens the connection and waits for the OnConnected notification.\n  * @private\n  * @param {Number} timeout - The time to wait for the OnConnected notification.\n  * @returns {Object} A promise containing the session state (SESSION_CREATED or SESSION_ATTACHED).\n  */\n  reopen(timeout) {\n    let timer;\n    let notificationResolve;\n    let notificationReceived = false;\n    const notificationPromise = new this.Promise((resolve) => { notificationResolve = resolve; });\n\n    const waitForNotification = () => {\n      if (!notificationReceived) {\n        timer = setTimeout(() => notificationResolve('SESSION_CREATED'), timeout);\n      }\n      return notificationPromise;\n    };\n\n    const onNotification = (data) => {\n      if (data.method !== 'OnConnected') return;\n      clearTimeout(timer);\n      notificationResolve(data.params.qSessionState);\n      notificationReceived = true;\n    };\n\n    this.rpc.on('notification', onNotification);\n\n    return this.rpc.open(true)\n      .then(waitForNotification)\n      .then((state) => {\n        this.rpc.removeListener('notification', onNotification);\n        return state;\n      })\n      .catch((err) => {\n        this.rpc.removeListener('notification', onNotification);\n        return this.Promise.reject(err);\n      });\n  }\n\n  /**\n  * Function used to build the get method names for Doc APIs.\n  * @private\n  * @param {String} type - The API type.\n  * @returns {String} Returns the get method name, or undefined if the type cannot be restored.\n  */\n  static buildGetMethodName(type) {\n    if (type === 'Field' || type === 'Variable') {\n      return null;\n    }\n    if (type === 'GenericVariable') {\n      return 'GetVariableById';\n    }\n    return type.replace('Generic', 'Get');\n  }\n}\n\nexport default SuspendResume;\n","const SUCCESS_KEY = 'qSuccess';\n\nexport default function deltaRequestInterceptor(session, request) {\n  const delta = session.config.protocol.delta\n    && request.outKey !== -1\n    && request.outKey !== SUCCESS_KEY;\n  if (delta) {\n    request.delta = delta;\n  }\n  return request;\n}\n","import createEnigmaError from '../error';\nimport errorCodes from '../error-codes';\n\n/**\n* Response interceptor for generating APIs. Handles the quirks of engine not\n* returning an error when an object is missing.\n* @private\n* @param {Session} session - The session the intercept is being executed on.\n* @param {Object} request - The JSON-RPC request.\n* @param {Object} response - The response.\n* @returns {Object} - Returns the generated API\n*/\nexport default function apiResponseInterceptor(session, request, response) {\n  if (response.qHandle && response.qType) {\n    return session.getObjectApi({\n      handle: response.qHandle,\n      type: response.qType,\n      id: response.qGenericId,\n      genericType: response.qGenericType,\n    });\n  }\n  if (response.qHandle === null && response.qType === null) {\n    const error = createEnigmaError(errorCodes.OBJECT_NOT_FOUND, 'Object not found');\n    return session.config.Promise.reject(error);\n  }\n  return response;\n}\n","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n","import originalExtend from 'extend';\n\nimport createEnigmaError from './error';\nimport errorCodes from './error-codes';\n\nconst extend = originalExtend.bind(null, true);\nconst JSONPatch = {};\nconst { isArray } = Array;\nfunction isObject(v) { return v != null && !Array.isArray(v) && typeof v === 'object'; }\nfunction isUndef(v) { return typeof v === 'undefined'; }\nfunction isFunction(v) { return typeof v === 'function'; }\n\n/**\n* Generate an exact duplicate (with no references) of a specific value.\n*\n* @private\n* @param {Object} The value to duplicate\n* @returns {Object} a unique, duplicated value\n*/\nfunction generateValue(val) {\n  if (val) {\n    return extend({}, { val }).val;\n  }\n  return val;\n}\n\n/**\n* An additional type checker used to determine if the property is of internal\n* use or not a type that can be translated into JSON (like functions).\n*\n* @private\n* @param {Object} obj The object which has the property to check\n* @param {String} The property name to check\n* @returns {Boolean} Whether the property is deemed special or not\n*/\nfunction isSpecialProperty(obj, key) {\n  return isFunction(obj[key])\n    || key.substring(0, 2) === '$$'\n    || key.substring(0, 1) === '_';\n}\n\n/**\n* Finds the parent object from a JSON-Pointer (\"/foo/bar/baz\" = \"bar\" is \"baz\" parent),\n* also creates the object structure needed.\n*\n* @private\n* @param {Object} data The root object to traverse through\n* @param {String} The JSON-Pointer string to use when traversing\n* @returns {Object} The parent object\n*/\nfunction getParent(data, str) {\n  const seperator = '/';\n  const parts = str.substring(1).split(seperator).slice(0, -1);\n  let numPart;\n\n  parts.forEach((part, i) => {\n    if (i === parts.length) {\n      return;\n    }\n    numPart = +part;\n    const newPart = !isNaN(numPart) ? [] : {};\n    data[numPart || part] = isUndef(data[numPart || part])\n      ? newPart\n      : data[part];\n    data = data[numPart || part];\n  });\n\n  return data;\n}\n\n/**\n* Cleans an object of all its properties, unless they're deemed special or\n* cannot be removed by configuration.\n*\n* @private\n* @param {Object} obj The object to clean\n*/\nfunction emptyObject(obj) {\n  Object.keys(obj).forEach((key) => {\n    const config = Object.getOwnPropertyDescriptor(obj, key);\n\n    if (config.configurable && !isSpecialProperty(obj, key)) {\n      delete obj[key];\n    }\n  });\n}\n\n/**\n* Compare an object with another, could be object, array, number, string, bool.\n* @private\n* @param {Object} a The first object to compare\n* @param {Object} a The second object to compare\n* @returns {Boolean} Whether the objects are identical\n*/\nfunction compare(a, b) {\n  let isIdentical = true;\n\n  if (isObject(a) && isObject(b)) {\n    if (Object.keys(a).length !== Object.keys(b).length) {\n      return false;\n    }\n    Object.keys(a).forEach((key) => {\n      if (!compare(a[key], b[key])) {\n        isIdentical = false;\n      }\n    });\n    return isIdentical;\n  }\n  if (isArray(a) && isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0, l = a.length; i < l; i += 1) {\n      if (!compare(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a === b;\n}\n\n/**\n* Generates patches by comparing two arrays.\n*\n* @private\n* @param {Array} oldA The old (original) array, which will be patched\n* @param {Array} newA The new array, which will be used to compare against\n* @returns {Array} An array of patches (if any)\n*/\nfunction patchArray(original, newA, basePath) {\n  let patches = [];\n  const oldA = original.slice();\n  let tmpIdx = -1;\n\n  function findIndex(a, id, idx) {\n    if (a[idx] && isUndef(a[idx].qInfo)) {\n      return null;\n    }\n    if (a[idx] && a[idx].qInfo.qId === id) {\n      // shortcut if identical\n      return idx;\n    }\n    for (let ii = 0, ll = a.length; ii < ll; ii += 1) {\n      if (a[ii] && a[ii].qInfo.qId === id) {\n        return ii;\n      }\n    }\n    return -1;\n  }\n\n  if (compare(newA, oldA)) {\n    // array is unchanged\n    return patches;\n  }\n\n  if (!isUndef(newA[0]) && isUndef(newA[0].qInfo)) {\n    // we cannot create patches without unique identifiers, replace array...\n    patches.push({\n      op: 'replace',\n      path: basePath,\n      value: newA,\n    });\n    return patches;\n  }\n\n  for (let i = oldA.length - 1; i >= 0; i -= 1) {\n    tmpIdx = findIndex(newA, oldA[i].qInfo && oldA[i].qInfo.qId, i);\n    if (tmpIdx === -1) {\n      patches.push({\n        op: 'remove',\n        path: `${basePath}/${i}`,\n      });\n      oldA.splice(i, 1);\n    } else {\n      patches = patches.concat(JSONPatch.generate(oldA[i], newA[tmpIdx], `${basePath}/${i}`));\n    }\n  }\n\n  for (let i = 0, l = newA.length; i < l; i += 1) {\n    tmpIdx = findIndex(oldA, newA[i].qInfo && newA[i].qInfo.qId);\n    if (tmpIdx === -1) {\n      patches.push({\n        op: 'add',\n        path: `${basePath}/${i}`,\n        value: newA[i],\n      });\n      oldA.splice(i, 0, newA[i]);\n    } else if (tmpIdx !== i) {\n      patches.push({\n        op: 'move',\n        path: `${basePath}/${i}`,\n        from: `${basePath}/${tmpIdx}`,\n      });\n      oldA.splice(i, 0, oldA.splice(tmpIdx, 1)[0]);\n    }\n  }\n  return patches;\n}\n\n/**\n* Generate an array of JSON-Patch:es following the JSON-Patch Specification Draft.\n*\n* See [specification draft](http://tools.ietf.org/html/draft-ietf-appsawg-json-patch-10)\n*\n* Does NOT currently generate patches for arrays (will replace them)\n* @private\n* @param {Object} original The object to patch to\n* @param {Object} newData The object to patch from\n* @param {String} [basePath] The base path to use when generating the paths for\n*                            the patches (normally not used)\n* @returns {Array} An array of patches\n*/\nJSONPatch.generate = function generate(original, newData, basePath) {\n  basePath = basePath || '';\n  let patches = [];\n\n  Object.keys(newData).forEach((key) => {\n    const val = generateValue(newData[key]);\n    const oldVal = original[key];\n    const tmpPath = `${basePath}/${key}`;\n\n    if (compare(val, oldVal) || isSpecialProperty(newData, key)) {\n      return;\n    }\n    if (isUndef(oldVal)) {\n      // property does not previously exist\n      patches.push({\n        op: 'add',\n        path: tmpPath,\n        value: val,\n      });\n    } else if (isObject(val) && isObject(oldVal)) {\n      // we need to generate sub-patches for this, since it already exist\n      patches = patches.concat(JSONPatch.generate(oldVal, val, tmpPath));\n    } else if (isArray(val) && isArray(oldVal)) {\n      patches = patches.concat(patchArray(oldVal, val, tmpPath));\n    } else {\n      // it's a simple property (bool, string, number)\n      patches.push({\n        op: 'replace',\n        path: `${basePath}/${key}`,\n        value: val,\n      });\n    }\n  });\n\n  Object.keys(original).forEach((key) => {\n    if (isUndef(newData[key]) && !isSpecialProperty(original, key)) {\n      // this property does not exist anymore\n      patches.push({\n        op: 'remove',\n        path: `${basePath}/${key}`,\n      });\n    }\n  });\n\n  return patches;\n};\n\n/**\n* Apply a list of patches to an object.\n* @private\n* @param {Object} original The object to patch\n* @param {Array} patches The list of patches to apply\n*/\nJSONPatch.apply = function apply(original, patches) {\n  patches.forEach((patch) => {\n    let parent = getParent(original, patch.path);\n    let key = patch.path.split('/').splice(-1)[0];\n    let target = key && isNaN(+key) ? parent[key] : parent[+key] || parent;\n    const from = patch.from ? patch.from.split('/').splice(-1)[0] : null;\n\n    if (patch.path === '/') {\n      parent = null;\n      target = original;\n    }\n\n    if (patch.op === 'add' || patch.op === 'replace') {\n      if (isArray(parent)) {\n        // trust indexes from patches, so don't replace the index if it's an add\n        if (key === '-') {\n          key = parent.length;\n        }\n        parent.splice(+key, patch.op === 'add' ? 0 : 1, patch.value);\n      } else if (isArray(target) && isArray(patch.value)) {\n        // keep array reference if possible...\n        target.length = 0;\n\n        const chunkSize = 1000;\n        for (let i = 0; i < patch.value.length; i += chunkSize) {\n          const chunk = patch.value.slice(i, i + chunkSize);\n          target.push(...chunk);\n        }\n      } else if (isObject(target) && isObject(patch.value)) {\n        // keep object reference if possible...\n        emptyObject(target);\n        extend(target, patch.value);\n      } else if (!parent) {\n        throw createEnigmaError(errorCodes.PATCH_HAS_NO_PARENT, 'Patchee is not an object we can patch');\n      } else {\n        // simple value\n        parent[key] = patch.value;\n      }\n    } else if (patch.op === 'move') {\n      const oldParent = getParent(original, patch.from);\n      if (isArray(parent)) {\n        parent.splice(+key, 0, oldParent.splice(+from, 1)[0]);\n      } else {\n        parent[key] = oldParent[from];\n        delete oldParent[from];\n      }\n    } else if (patch.op === 'remove') {\n      if (isArray(parent)) {\n        parent.splice(+key, 1);\n      } else {\n        delete parent[key];\n      }\n    }\n  });\n};\n\n/**\n* Deep clone an object.\n* @private\n* @param {Object} obj The object to clone\n* @returns {Object} A new object identical to the `obj`\n*/\nJSONPatch.clone = function clone(obj) {\n  return extend({}, obj);\n};\n\n/**\n* Creates a JSON-patch.\n* @private\n* @param {String} op The operation of the patch. Available values: \"add\", \"remove\", \"move\"\n* @param {Object} [val] The value to set the `path` to. If `op` is `move`, `val`\n*                       is the \"from JSON-path\" path\n* @param {String} path The JSON-path for the property to change (e.g. \"/qHyperCubeDef/columnOrder\")\n* @returns {Object} A patch following the JSON-patch specification\n*/\nJSONPatch.createPatch = function createPatch(op, val, path) {\n  const patch = {\n    op: op.toLowerCase(),\n    path,\n  };\n  if (patch.op === 'move') {\n    patch.from = val;\n  } else if (typeof val !== 'undefined') {\n    patch.value = val;\n  }\n  return patch;\n};\n\n/**\n* Apply the differences of two objects (keeping references if possible).\n* Identical to running `JSONPatch.apply(original, JSONPatch.generate(original, newData));`\n* @private\n* @param {Object} original The object to update/patch\n* @param {Object} newData the object to diff against\n*\n* @example\n* var obj1 = { foo: [1,2,3], bar: { baz: true, qux: 1 } };\n* var obj2 = { foo: [4,5,6], bar: { baz: false } };\n* JSONPatch.updateObject(obj1, obj2);\n* // => { foo: [4,5,6], bar: { baz: false } };\n*/\nJSONPatch.updateObject = function updateObject(original, newData) {\n  if (!Object.keys(original).length) {\n    extend(original, newData);\n    return;\n  }\n  JSONPatch.apply(original, JSONPatch.generate(original, newData));\n};\n\nexport default JSONPatch;\n","import JSONPatch from '../json-patch';\nimport KeyValueCache from '../key-value-cache';\n\nimport createEnigmaError from '../error';\nimport errorCodes from '../error-codes';\n\nconst sessions = {};\n\n/**\n* Function to make sure we release handle caches when they are closed.\n* @private\n* @param {Session} session The session instance to listen on.\n*/\nconst bindSession = (session) => {\n  if (!sessions[session.id]) {\n    const cache = {};\n    sessions[session.id] = cache;\n    session.on('traffic:received', (data) => data.close && data.close.forEach((handle) => delete cache[handle]));\n    session.on('closed', () => delete sessions[session.id]);\n  }\n};\n\n/**\n* Simple function that ensures the session events has been bound, and returns\n* either an existing key-value cache or creates one for the specified handle.\n* @private\n* @param {Session} session The session that owns the handle.\n* @param {Number} handle The object handle to retrieve the cache for.\n* @returns {KeyValueCache} The cache instance.\n*/\nconst getHandleCache = (session, handle) => {\n  bindSession(session);\n  const cache = sessions[session.id];\n  if (!cache[handle]) {\n    cache[handle] = new KeyValueCache();\n  }\n  return cache[handle];\n};\n\n/**\n* Function used to apply a list of patches and return the patched value.\n* @private\n* @param {Session} session The session.\n* @param {Number} handle The object handle.\n* @param {String} cacheId The cacheId.\n* @param {Array} patches The patches.\n* @returns {Object} Returns the patched value.\n*/\nconst patchValue = (session, handle, cacheId, patches) => {\n  const cache = getHandleCache(session, handle);\n  let entry = cache.get(cacheId);\n  if (typeof entry === 'undefined') {\n    entry = Array.isArray(patches[0].value) ? [] : {};\n  }\n  if (patches.length) {\n    if (patches[0].path === '/' && typeof patches[0].value !== 'object') {\n      // 'plain' values on root path is not supported (no object reference),\n      // so we simply store the value directly:\n      entry = patches[0].value;\n    } else {\n      JSONPatch.apply(entry, patches);\n    }\n    cache.set(cacheId, entry);\n  }\n  return entry;\n};\n\n/**\n* Process delta interceptor.\n* @private\n* @param {Session} session The session the intercept is being executed on.\n* @param {Object} request The JSON-RPC request.\n* @param {Object} response The response.\n* @returns {Object} Returns the patched response\n*/\nexport default function deltaResponseInterceptor(session, request, response) {\n  const { delta, result } = response;\n  if (delta) {\n    // when delta is on the response data is expected to be an array of patches:\n    Object.keys(result).forEach((key) => {\n      if (!Array.isArray(result[key])) {\n        throw createEnigmaError(errorCodes.EXPECTED_ARRAY_OF_PATCHES, 'Unexpected RPC response, expected array of patches');\n      }\n      result[key] = patchValue(session, request.handle, `${request.method}-${key}`, result[key]);\n    });\n    // return a cloned response object to avoid patched object references:\n    return JSON.parse(JSON.stringify(response));\n  }\n  return response;\n}\n\n// export object reference for testing purposes:\ndeltaResponseInterceptor.sessions = sessions;\n","/**\n* Process error interceptor.\n* @private\n* @param {Session} session - The session the intercept is being executed on.\n* @param {Object} request - The JSON-RPC request.\n* @param {Object} response - The response.\n* @returns {Object} - Returns the defined error for an error, else the response.\n*/\nexport default function errorResponseInterceptor(session, request, response) {\n  if (typeof response.error !== 'undefined') {\n    const data = response.error;\n    const error = new Error(data.message);\n    error.code = data.code;\n    error.parameter = data.parameter;\n    return session.config.Promise.reject(error);\n  }\n  return response;\n}\n","const RETURN_KEY = 'qReturn';\n\n/**\n* Picks out the result \"out\" parameter based on the QIX method+schema, with\n* some specific handling for some methods that breaks the predictable protocol.\n* @private\n* @param {Session} session - The session the intercept is being executed on.\n* @param {Object} request - The JSON-RPC request.\n* @param {Object} response - The response.\n* @returns {Object} - Returns the result property on the response\n*/\nexport default function outParamResponseInterceptor(session, request, response) {\n  if (request.method === 'CreateSessionApp' || request.method === 'CreateSessionAppFromApp') {\n    // this method returns multiple out params that we need\n    // to normalize before processing the response further:\n    response[RETURN_KEY].qGenericId = response.qSessionAppId || response[RETURN_KEY].qGenericId;\n  } else if (request.method === 'GetInteract') {\n    // this method returns a qReturn value when it should only return\n    // meta.outKey:\n    delete response[RETURN_KEY];\n  }\n\n  if (hasOwnProperty.call(response, RETURN_KEY)) {\n    return response[RETURN_KEY];\n  }\n  if (request.outKey !== -1) {\n    return response[request.outKey];\n  }\n\n  return response;\n}\n","/**\n* Process result interceptor.\n* @private\n* @param {Session} session - The session the intercept is being executed on.\n* @param {Object} request - The JSON-RPC request.\n* @param {Object} response - The response.\n* @returns {Object} - Returns the result property on the response\n*/\nexport default function resultResponseInterceptor(session, request, response) {\n  return response.result;\n}\n","import deltaRequest from './interceptors/delta-request-interceptor';\nimport apiResponse from './interceptors/api-response-interceptor';\nimport deltaResponse from './interceptors/delta-response-interceptor';\nimport errorResponse from './interceptors/error-response-interceptor';\nimport outParamResponse from './interceptors/out-param-response-interceptor';\nimport resultResponse from './interceptors/result-response-interceptor';\n\n/**\n * Interceptor is a concept similar to mixins, but runs on a lower level. The interceptor concept\n * can augment either the requests (i.e. before sent to QIX Engine), or the responses (i.e. after\n * QIX Engine has sent a response). The interceptor promises run in parallel to the regular\n * promises used in enigma.js, which means that it can be really useful when you want to normalize\n * behaviors in your application.\n * @interface Interceptor\n */\n\n/**\n * @class InterceptorRequest\n * @implements {Interceptor}\n * @example <caption>Implement a request interceptor</caption>\n * const enigma = require('enigma.js');\n * const WebSocket = require('ws');\n * const schema = require('enigma.js/schemas/12.20.0.json');\n *\n * const session = enigma.create({\n *   schema,\n *   url: 'ws://localhost:9076/app/engineData',\n *   createSocket: (url) => new WebSocket(url),\n *   requestInterceptors: [{\n *     onFulfilled: function logRequest(sessionReference, request) {\n *       console.log('Request being sent', request);\n *       return request;\n *     }\n *   },\n * });\n */\n\n/**\n * @class InterceptorResponse\n * @implements {Interceptor}\n * @example <caption>Implement a request interceptor</caption>\n * const enigma = require('enigma.js');\n * const WebSocket = require('ws');\n * const schema = require('enigma.js/schemas/12.20.0.json');\n *\n * const session = enigma.create({\n *   schema,\n *   url: 'ws://localhost:9076/app/engineData',\n *   createSocket: (url) => new WebSocket(url),\n *   responseInterceptors: [{\n *     onRejected: function logError(sessionReference, request, error) {\n *       console.log('Error returned from QIX engine', error, 'Originating request:', request);\n *       // throw error so it's continued to be rejected:\n *       throw error;\n *     }\n *   },\n * });\n */\n\n/**\n * This method is invoked when a request is about to be sent to QIX Engine.\n * @function InterceptorRequest#onFulfilled\n * @param {Session} session The session executing the interceptor.\n * @param {Object} request The JSON-RPC request that will be sent.\n */\n\n/**\n * This method is invoked when a previous interceptor has rejected the\n * promise; use this to handle, for example, errors before they are sent into mixins.\n * @function InterceptorResponse#onRejected\n * @param {Session} session The session executing the interceptor. You may use .retry() to retry\n * sending it to QIX Engine.\n * @param {Object} request The JSON-RPC request resulting in this error.\n * @param {Object} error Whatever the previous interceptor is rejected with.\n */\n\n/**\n * This method is invoked when a promise has been successfully resolved;\n * use this to modify the result or reject the promise chain before it is sent\n * to mixins.\n * @function InterceptorResponse#onFulfilled\n * @param {Session} session The session executing the interceptor.\n * @param {Object} request The JSON-RPC request resulting in this response.\n * @param {Object} result Whatever the previous interceptor is resolved with.\n */\nclass Intercept {\n  /**\n  * Create a new Intercept instance.\n  * @private\n  * @param {Object} options The configuration options for this class.\n  * @param {Promise<Object>} options.Promise The promise constructor to use.\n  * @param {ApiCache} options.apis The ApiCache instance to use.\n  * @param {Array<Object>} [options.request] The additional request interceptors to use.\n  * @param {Array<Object>} [options.response] The additional response interceptors to use.\n  */\n  constructor(options) {\n    Object.assign(this, options);\n    this.request = [{ onFulfilled: deltaRequest }, ...this.request || []];\n    this.response = [\n      { onFulfilled: errorResponse },\n      { onFulfilled: deltaResponse },\n      { onFulfilled: resultResponse },\n      { onFulfilled: outParamResponse },\n      ...this.response || [],\n      { onFulfilled: apiResponse },\n    ];\n  }\n\n  /**\n  * Execute the request interceptor queue, each interceptor will get the result from\n  * the previous interceptor.\n  * @private\n  * @param {Session} session The session instance to execute against.\n  * @param {Promise<Object>} promise The promise to chain on to.\n  * @returns {Promise<Object>}\n  */\n  executeRequests(session, promise) {\n    return this.request.reduce((interception, interceptor) => {\n      const intercept = interceptor.onFulfilled\n        && interceptor.onFulfilled.bind(this, session);\n      return interception.then(intercept);\n    }, promise);\n  }\n\n  /**\n  * Execute the response interceptor queue, each interceptor will get the result from\n  * the previous interceptor.\n  * @private\n  * @param {Session} session The session instance to execute against.\n  * @param {Promise<Object>} promise The promise to chain on to.\n  * @param {Object} request The JSONRPC request object for the intercepted response.\n  * @returns {Promise<Object>}\n  */\n  executeResponses(session, promise, request) {\n    return this.response.reduce((interception, interceptor) => interception.then(\n      interceptor.onFulfilled && interceptor.onFulfilled.bind(this, session, request),\n      interceptor.onRejected && interceptor.onRejected.bind(this, session, request),\n    ), promise);\n  }\n}\n\nexport default Intercept;\n","import KeyValueCache from './key-value-cache';\n\n/**\n* API cache for instances of QIX types, e.g. GenericObject.\n* @private\n* @extends KeyValueCache\n*/\nclass ApiCache extends KeyValueCache {\n  /**\n  * Adds an API.\n  * @private\n  * @function ApiCache#add\n  * @param {Number} handle - The handle for the API.\n  * @param {*} api - The API.\n  * @returns {{api: *}} The entry.\n  */\n  add(handle, api) {\n    const entry = { api };\n    super.add(handle.toString(), entry);\n    api.on('closed', () => this.remove(handle));\n    return entry;\n  }\n\n  /**\n  * Gets an API.\n  * @private\n  * @function ApiCache#getApi\n  * @param {Number} handle - The handle for the API.\n  * @returns {*} The API for the handle.\n  */\n  getApi(handle) {\n    const entry = typeof handle !== 'undefined' ? this.get(handle.toString()) : undefined;\n    return entry && entry.api;\n  }\n\n  /**\n  * Gets a list of APIs.\n  * @private\n  * @function ApiCache#getApis\n  * @returns {Array} The list of entries including `handle` and `api` properties for each entry.\n  */\n  getApis() {\n    return super.getAll().map((entry) => ({\n      handle: entry.key,\n      api: entry.value.api,\n    }));\n  }\n\n  /**\n  * Gets a list of APIs with a given type.\n  * @private\n  * @function ApiCache#getApisByType\n  * @param {String} type - The type of APIs to get.\n  * @returns {Array} The list of entries including `handle` and `api` properties for each entry.\n  */\n  getApisByType(type) {\n    return this.getApis().filter((entry) => entry.api.type === type);\n  }\n}\n\nexport default ApiCache;\n","import Session from './session';\nimport Schema from './schema';\nimport RPC from './rpc';\nimport SuspendResume from './suspend-resume';\nimport Intercept from './intercept';\nimport ApiCache from './api-cache';\n\nimport createEnigmaError from './error';\nimport errorCodes from './error-codes';\n\n/**\n * The enigma.js configuration object.\n * @interface Configuration\n * @property {Object} schema Object containing the specification for the API to generate.\n * Corresponds to a specific version of the QIX Engine API.\n * @property {String} url String containing a proper websocket URL to QIX Engine.\n * @property {Function} [createSocket] A function to use when instantiating the WebSocket,\n * mandatory for Node.js.\n * @property {Object} [Promise] ES6-compatible Promise library.\n * @property {Boolean} [suspendOnClose=false] Set to true if the session should be suspended\n * instead of closed when the websocket is closed.\n * @property {Array<Mixin>} [mixins=[]] Mixins to extend/augment the QIX Engine API. Mixins\n * are applied in the array order.\n * @property {Array} [requestInterceptors=[]] Interceptors for augmenting requests before they\n * are sent to QIX Engine. Interceptors are applied in the array order.\n * @property {Array} [responseInterceptors=[]] Interceptors for augmenting responses before they\n * are passed into mixins and end-users. Interceptors are applied in the array order.\n * @property {Object} [protocol={}] An object containing additional JSON-RPC request parameters.\n * @property {Boolean} [protocol.delta=true] Set to false to disable the use of the\n * bandwidth-reducing delta protocol.\n * @example <caption>Example defining a configuration object</caption>\n * const enigma = require('enigma.js');\n * const WebSocket = require('ws');\n * const bluebird = require('bluebird');\n * const schema = require('enigma.js/schemas/12.20.0.json');\n *\n * const config = {\n *  schema,\n *  url: 'ws://localhost:4848/app/engineData',\n *  createSocket: url => new WebSocket(url),\n *  Promise: bluebird,\n *  suspendOnClose: true,\n *  mixins: [{ types: ['Global'], init: () => console.log('Mixin ran') }],\n *  protocol: { delta: false },\n * };\n *\n * enigma.create(config).open().then((global) => {\n *   // global === QIX global interface\n *   process.exit(0);\n * });\n */\n\n/**\n * The mixin concept allows you to add or override QIX Engine API functionality. A mixin is\n * basically a JavaScript object describing which types it modifies, and a list of functions\n * for extending and overriding the API for those types.\n *\n * QIX Engine types like, for example, GenericObject, Doc, GenericBookmark, are supported but\n * also custom GenericObject types such as barchart, story and myCustomType. An API will get\n * both their generic type as well as custom type mixins applied.\n *\n * Mixins that are bound to several different types can find the current API type in the\n * `genericType` or `type` members. `this.type` would, for instance, return `GenericObject` and\n * `this.genericType` would return `barchart`.\n *\n * See the Mixins examples on how to use it. Below is an outline of what the mixin API consists of.\n *\n * @interface Mixin\n * @property {String|Array<String>} types String or array of strings containing the API-types that\n * will be mixed in.\n * @property {Object} [extend] Object literal containing the methods that will be extended on the\n * specified API.\n * @property {Object} [override] Object literal containing the methods to override existing methods.\n * @property {Function} [init] Init function that, if defined, will run when an API is instantiated.\n * It runs with Promise and API object as parameters.\n */\n\n/**\n * The API for generated APIs depends on the QIX Engine schema you pass into your Configuration, and\n * on what QIX struct the API has.\n *\n * All API calls made using the generated APIs will return promises that are either resolved or\n * rejected depending on how the QIX Engine responds.\n *\n * @interface API\n * @property {String} id Contains the unique identifier for this API.\n * @property {String} type Contains the schema class name for this API.\n * @property {String} genericType Corresponds to the qInfo.qType property on the generic object's\n * properties object.\n * @property {Session} session Contains a reference to the session that this API belongs to.\n * @property {Number} handle Contains the handle QIX Engine assigned to the API. Used interally in\n * enigma.js for caches and JSON-RPC requests.\n * @example <caption>Example using `global` and `generic object` struct APIs</caption>\n * global.openDoc('my-document.qvf').then((doc) => {\n *   doc.createObject({ qInfo: { qType: 'my-object' } }).then(api => { });\n *   doc.getObject('object-id').then(api => { });\n *   doc.getBookmark('bookmark-id').then(api => { });\n * });\n */\n\n/**\n * Handles changes on the API. The changed event is triggered whenever enigma.js or QIX Engine has\n * identified potential changes on the underlying properties or hypercubes and you should re-fetch\n * your data.\n * @event API#changed\n * @type {Object}\n * @example <caption>Bind the `changed` event</caption>\n * api.on('changed', () => {\n *   api.getLayout().then(layout => { });\n * });\n */\n\n/**\n * Handles closed API. The closed event is triggered whenever QIX Engine considers an API closed.\n * It usually means that it no longer exists in the QIX Engine document or session.\n * @event API#closed\n * @type {Object}\n * @example <caption>Bind the `closed` event</caption>\n * api.on('closed', () => {\n *   console.log(api.id, 'was closed');\n * });\n */\n\n/**\n * Handles JSON-RPC requests/responses for this API. Generally used in debugging purposes.\n * `traffic:*` will handle all websocket messages, `traffic:sent` will handle outgoing messages\n * and `traffic:received` will handle incoming messages.\n * @event API#traffic\n * @type {Object}\n * @example <caption>Bind the traffic events</caption>\n * // bind both in- and outbound traffic to console.log:\n * api.on('traffic:*', console.log);\n * // bind outbound traffic to console.log:\n * api.on('traffic:sent', console.log);\n * // bind inbound traffic to console.log:\n * api.on('traffic:received', console.log);\n */\n\nclass Enigma {\n  /**\n   * Function used to get a session.\n   * @private\n   * @param {Configuration} config The configuration object for this session.\n   * @returns {Session} Returns a session instance.\n   */\n  static getSession(config) {\n    const {\n      createSocket,\n      Promise,\n      requestInterceptors,\n      responseInterceptors,\n      url,\n    } = config;\n    const apis = new ApiCache();\n    const intercept = new Intercept({\n      apis,\n      Promise,\n      request: requestInterceptors,\n      response: responseInterceptors,\n    });\n    const rpc = new RPC({ createSocket, Promise, url });\n    const suspendResume = new SuspendResume({ apis, Promise, rpc });\n    const session = new Session({\n      apis,\n      config,\n      intercept,\n      rpc,\n      suspendResume,\n    });\n    return session;\n  }\n\n  /**\n  * Function used to configure defaults.\n  * @private\n  * @param {Configuration} config The configuration object for how to connect\n  *                               and retrieve end QIX APIs.\n  */\n  static configureDefaults(config) {\n    if (!config) {\n      throw createEnigmaError(errorCodes.NO_CONFIG_SUPPLIED, 'You need to supply a configuration.');\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    if (!config.Promise && typeof Promise === 'undefined') {\n      throw createEnigmaError(errorCodes.PROMISE_REQUIRED, 'Your environment has no Promise implementation. You must provide a Promise implementation in the config.');\n    }\n\n    if (typeof config.createSocket !== 'function' && typeof WebSocket === 'function') {\n      // eslint-disable-next-line no-undef\n      config.createSocket = (url) => new WebSocket(url);\n    }\n\n    if (typeof config.suspendOnClose === 'undefined') {\n      config.suspendOnClose = false;\n    }\n\n    config.protocol = config.protocol || {};\n    config.protocol.delta = typeof config.protocol.delta !== 'undefined' ? config.protocol.delta : true;\n    // eslint-disable-next-line no-restricted-globals\n    config.Promise = config.Promise || Promise;\n    config.mixins = config.mixins || [];\n    config.definition = config.definition || new Schema(config);\n  }\n\n  /**\n  * Function used to create a QIX session.\n  * @entry\n  * @param {Configuration} config The configuration object for the QIX session.\n  * @returns {Session} Returns a new QIX session.\n  * @example <caption>Example minimal session creation</caption>\n  * const enigma = require('enigma.js');\n  * const schema = require('enigma.js/schemas/12.20.0.json');\n  * const WebSocket = require('ws');\n  * const config = {\n  *   schema,\n  *   url: 'ws://localhost:9076/app/engineData',\n  *   createSocket: url => new WebSocket(url),\n  * };\n  * const session = enigma.create(config);\n  */\n  static create(config) {\n    Enigma.configureDefaults(config);\n    config.mixins.forEach((mixin) => {\n      config.definition.registerMixin(mixin);\n    });\n    return Enigma.getSession(config);\n  }\n}\n\nexport default Enigma;\n"]},"metadata":{},"sourceType":"script"}